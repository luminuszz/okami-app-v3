/**
 * Generated by orval v7.3.0 üç∫
 * Do not edit manually.
 * Okami API
 * The Okami rest api
 * OpenAPI spec version: 1.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  AccessToken,
  AddRowInCalendarDto,
  AddWorkInCustomListDto,
  CalendarModel,
  CompareSubscriberAuthTokenDto,
  CreateAdminHashCodeDto,
  CreateCalendarDto,
  CreateCustomListDto,
  CreateCustomListResponseModel,
  CreateManySearchTokensDto,
  CreateSearchTokenDto,
  CreateSharedWorkDto,
  CreateSharedWorkResponseModel,
  CreateTagDto,
  CreateUserDto,
  CustomListModel,
  CustomListWithWorksModel,
  FetchSharedWorkQueryResponse,
  GetWorkUploadUrlDto,
  IntegrationControllerListSearchTokensParams,
  LoggerControllerHealthCheck200,
  LoggerControllerHealthCheck503,
  LogoutDto,
  MakeSessionValidator,
  MarkWorkUnreadDto,
  NotificationHttp,
  PaymentStatusModel,
  RefreshTokenDto,
  RefreshTokenModel,
  RefreshTokenOnlyModel,
  RegisterMobilePushSubscriberDto,
  RegisterWebPushSubscriptionDto,
  ResetPasswordDto,
  ResetUserPasswordDto,
  ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams,
  ScrappingReportDto,
  ScrappingReportWorkModel,
  SearchTokenControllerListSearchTokensParams,
  SearchTokenHttp,
  SendAuthCodeByEmailValidator,
  SendResetPasswordEmailDto,
  SharedCustomListModel,
  TagControllerFilterTagParams,
  TagControllerListTagsParams,
  TagModel,
  TagModelPaged,
  ToggleShareCollectionDto,
  UpdateChapterDto,
  UpdateCustomListDto,
  UpdateNotionDatabaseIdDto,
  UpdateTagDto,
  UpdateTelegramChatIdValidator,
  UpdateUserDto,
  UpdateWorkDto,
  UserHttp,
  ValidateEmailDto,
  WorkControllerListUserWorksPagedParams,
  WorkControllerListUserWorksParams,
  WorkHttp,
  WorkModelPaged,
  WorkUploadUrlResponseModel
} from './models'
import { customInstance } from '../lib/axios/index';
import type { ErrorType, BodyType } from '../lib/axios/index';



type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


export const workControllerCreateWork = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append('data', )

      return customInstance<void>(
      {url: `/work`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getWorkControllerCreateWorkMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerCreateWork>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof workControllerCreateWork>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof workControllerCreateWork>>, void> = () => {
          

          return  workControllerCreateWork(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WorkControllerCreateWorkMutationResult = NonNullable<Awaited<ReturnType<typeof workControllerCreateWork>>>
    
    export type WorkControllerCreateWorkMutationError = ErrorType<unknown>

    export const useWorkControllerCreateWork = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerCreateWork>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof workControllerCreateWork>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getWorkControllerCreateWorkMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const workControllerGetWorkById = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkHttp>(
      {url: `/work/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getWorkControllerGetWorkByIdQueryKey = (id: string,) => {
    return [`/work/${id}`] as const;
    }

    
export const getWorkControllerGetWorkByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof workControllerGetWorkById>>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerGetWorkById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerGetWorkByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerGetWorkById>>> = ({ signal }) => workControllerGetWorkById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerGetWorkById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerGetWorkByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerGetWorkById>>>
export type WorkControllerGetWorkByIdInfiniteQueryError = ErrorType<unknown>


export function useWorkControllerGetWorkByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerGetWorkById>>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerGetWorkById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerGetWorkById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerGetWorkByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerGetWorkById>>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerGetWorkById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerGetWorkById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerGetWorkByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerGetWorkById>>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerGetWorkById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerGetWorkByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerGetWorkById>>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerGetWorkById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerGetWorkByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getWorkControllerGetWorkByIdQueryOptions = <TData = Awaited<ReturnType<typeof workControllerGetWorkById>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerGetWorkById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerGetWorkByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerGetWorkById>>> = ({ signal }) => workControllerGetWorkById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof workControllerGetWorkById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerGetWorkByIdQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerGetWorkById>>>
export type WorkControllerGetWorkByIdQueryError = ErrorType<unknown>


export function useWorkControllerGetWorkById<TData = Awaited<ReturnType<typeof workControllerGetWorkById>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerGetWorkById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerGetWorkById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerGetWorkById<TData = Awaited<ReturnType<typeof workControllerGetWorkById>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerGetWorkById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerGetWorkById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerGetWorkById<TData = Awaited<ReturnType<typeof workControllerGetWorkById>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerGetWorkById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerGetWorkById<TData = Awaited<ReturnType<typeof workControllerGetWorkById>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerGetWorkById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerGetWorkByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const workControllerDeleteWork = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/work/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getWorkControllerDeleteWorkMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerDeleteWork>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof workControllerDeleteWork>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof workControllerDeleteWork>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  workControllerDeleteWork(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WorkControllerDeleteWorkMutationResult = NonNullable<Awaited<ReturnType<typeof workControllerDeleteWork>>>
    
    export type WorkControllerDeleteWorkMutationError = ErrorType<unknown>

    export const useWorkControllerDeleteWork = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerDeleteWork>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof workControllerDeleteWork>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getWorkControllerDeleteWorkMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const workControllerUpdateChapter = (
    id: string,
    updateChapterDto: BodyType<UpdateChapterDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/work/${id}/update-chapter`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateChapterDto
    },
      options);
    }
  


export const getWorkControllerUpdateChapterMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerUpdateChapter>>, TError,{id: string;data: BodyType<UpdateChapterDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof workControllerUpdateChapter>>, TError,{id: string;data: BodyType<UpdateChapterDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof workControllerUpdateChapter>>, {id: string;data: BodyType<UpdateChapterDto>}> = (props) => {
          const {id,data} = props ?? {};

          return  workControllerUpdateChapter(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WorkControllerUpdateChapterMutationResult = NonNullable<Awaited<ReturnType<typeof workControllerUpdateChapter>>>
    export type WorkControllerUpdateChapterMutationBody = BodyType<UpdateChapterDto>
    export type WorkControllerUpdateChapterMutationError = ErrorType<unknown>

    export const useWorkControllerUpdateChapter = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerUpdateChapter>>, TError,{id: string;data: BodyType<UpdateChapterDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof workControllerUpdateChapter>>,
        TError,
        {id: string;data: BodyType<UpdateChapterDto>},
        TContext
      > => {

      const mutationOptions = getWorkControllerUpdateChapterMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const workControllerMarkRead = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/work/${id}/mark-read`, method: 'PATCH'
    },
      options);
    }
  


export const getWorkControllerMarkReadMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerMarkRead>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof workControllerMarkRead>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof workControllerMarkRead>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  workControllerMarkRead(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WorkControllerMarkReadMutationResult = NonNullable<Awaited<ReturnType<typeof workControllerMarkRead>>>
    
    export type WorkControllerMarkReadMutationError = ErrorType<unknown>

    export const useWorkControllerMarkRead = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerMarkRead>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof workControllerMarkRead>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getWorkControllerMarkReadMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const workControllerMarkUnread = (
    id: string,
    markWorkUnreadDto: BodyType<MarkWorkUnreadDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/work/${id}/mark-unread`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: markWorkUnreadDto
    },
      options);
    }
  


export const getWorkControllerMarkUnreadMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerMarkUnread>>, TError,{id: string;data: BodyType<MarkWorkUnreadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof workControllerMarkUnread>>, TError,{id: string;data: BodyType<MarkWorkUnreadDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof workControllerMarkUnread>>, {id: string;data: BodyType<MarkWorkUnreadDto>}> = (props) => {
          const {id,data} = props ?? {};

          return  workControllerMarkUnread(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WorkControllerMarkUnreadMutationResult = NonNullable<Awaited<ReturnType<typeof workControllerMarkUnread>>>
    export type WorkControllerMarkUnreadMutationBody = BodyType<MarkWorkUnreadDto>
    export type WorkControllerMarkUnreadMutationError = ErrorType<unknown>

    export const useWorkControllerMarkUnread = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerMarkUnread>>, TError,{id: string;data: BodyType<MarkWorkUnreadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof workControllerMarkUnread>>,
        TError,
        {id: string;data: BodyType<MarkWorkUnreadDto>},
        TContext
      > => {

      const mutationOptions = getWorkControllerMarkUnreadMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const workControllerFetchForWorkersRead = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkHttp[]>(
      {url: `/work/fetch-for-workers-read`, method: 'GET', signal
    },
      options);
    }
  

export const getWorkControllerFetchForWorkersReadQueryKey = () => {
    return [`/work/fetch-for-workers-read`] as const;
    }

    
export const getWorkControllerFetchForWorkersReadInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerFetchForWorkersReadQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>> = ({ signal }) => workControllerFetchForWorkersRead(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerFetchForWorkersReadInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>>
export type WorkControllerFetchForWorkersReadInfiniteQueryError = ErrorType<unknown>


export function useWorkControllerFetchForWorkersReadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerFetchForWorkersReadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerFetchForWorkersReadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerFetchForWorkersReadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerFetchForWorkersReadInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getWorkControllerFetchForWorkersReadQueryOptions = <TData = Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerFetchForWorkersReadQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>> = ({ signal }) => workControllerFetchForWorkersRead(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerFetchForWorkersReadQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>>
export type WorkControllerFetchForWorkersReadQueryError = ErrorType<unknown>


export function useWorkControllerFetchForWorkersRead<TData = Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerFetchForWorkersRead<TData = Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerFetchForWorkersRead<TData = Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerFetchForWorkersRead<TData = Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerFetchForWorkersReadQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const workControllerFetchForWorkersUnread = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkHttp[]>(
      {url: `/work/fetch-for-workers-unread`, method: 'GET', signal
    },
      options);
    }
  

export const getWorkControllerFetchForWorkersUnreadQueryKey = () => {
    return [`/work/fetch-for-workers-unread`] as const;
    }

    
export const getWorkControllerFetchForWorkersUnreadInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerFetchForWorkersUnreadQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>> = ({ signal }) => workControllerFetchForWorkersUnread(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerFetchForWorkersUnreadInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>>
export type WorkControllerFetchForWorkersUnreadInfiniteQueryError = ErrorType<unknown>


export function useWorkControllerFetchForWorkersUnreadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerFetchForWorkersUnreadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerFetchForWorkersUnreadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerFetchForWorkersUnreadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerFetchForWorkersUnreadInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getWorkControllerFetchForWorkersUnreadQueryOptions = <TData = Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerFetchForWorkersUnreadQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>> = ({ signal }) => workControllerFetchForWorkersUnread(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerFetchForWorkersUnreadQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>>
export type WorkControllerFetchForWorkersUnreadQueryError = ErrorType<unknown>


export function useWorkControllerFetchForWorkersUnread<TData = Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerFetchForWorkersUnread<TData = Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerFetchForWorkersUnread<TData = Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerFetchForWorkersUnread<TData = Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchForWorkersUnread>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerFetchForWorkersUnreadQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const workControllerGetWorksListForExtension = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/work/list/extension`, method: 'GET', signal
    },
      options);
    }
  

export const getWorkControllerGetWorksListForExtensionQueryKey = () => {
    return [`/work/list/extension`] as const;
    }

    
export const getWorkControllerGetWorksListForExtensionInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerGetWorksListForExtensionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>> = ({ signal }) => workControllerGetWorksListForExtension(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerGetWorksListForExtensionInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>>
export type WorkControllerGetWorksListForExtensionInfiniteQueryError = ErrorType<unknown>


export function useWorkControllerGetWorksListForExtensionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerGetWorksListForExtensionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerGetWorksListForExtensionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerGetWorksListForExtensionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerGetWorksListForExtensionInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getWorkControllerGetWorksListForExtensionQueryOptions = <TData = Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerGetWorksListForExtensionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>> = ({ signal }) => workControllerGetWorksListForExtension(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerGetWorksListForExtensionQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>>
export type WorkControllerGetWorksListForExtensionQueryError = ErrorType<unknown>


export function useWorkControllerGetWorksListForExtension<TData = Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerGetWorksListForExtension<TData = Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerGetWorksListForExtension<TData = Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerGetWorksListForExtension<TData = Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerGetWorksListForExtension>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerGetWorksListForExtensionQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const workControllerUpdateWork = (
    id: string,
    updateWorkDto: BodyType<UpdateWorkDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/work/update-work/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateWorkDto
    },
      options);
    }
  


export const getWorkControllerUpdateWorkMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerUpdateWork>>, TError,{id: string;data: BodyType<UpdateWorkDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof workControllerUpdateWork>>, TError,{id: string;data: BodyType<UpdateWorkDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof workControllerUpdateWork>>, {id: string;data: BodyType<UpdateWorkDto>}> = (props) => {
          const {id,data} = props ?? {};

          return  workControllerUpdateWork(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WorkControllerUpdateWorkMutationResult = NonNullable<Awaited<ReturnType<typeof workControllerUpdateWork>>>
    export type WorkControllerUpdateWorkMutationBody = BodyType<UpdateWorkDto>
    export type WorkControllerUpdateWorkMutationError = ErrorType<unknown>

    export const useWorkControllerUpdateWork = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerUpdateWork>>, TError,{id: string;data: BodyType<UpdateWorkDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof workControllerUpdateWork>>,
        TError,
        {id: string;data: BodyType<UpdateWorkDto>},
        TContext
      > => {

      const mutationOptions = getWorkControllerUpdateWorkMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const workControllerMarkFinished = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/work/mark-finished/${id}`, method: 'PATCH'
    },
      options);
    }
  


export const getWorkControllerMarkFinishedMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerMarkFinished>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof workControllerMarkFinished>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof workControllerMarkFinished>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  workControllerMarkFinished(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WorkControllerMarkFinishedMutationResult = NonNullable<Awaited<ReturnType<typeof workControllerMarkFinished>>>
    
    export type WorkControllerMarkFinishedMutationError = ErrorType<unknown>

    export const useWorkControllerMarkFinished = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerMarkFinished>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof workControllerMarkFinished>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getWorkControllerMarkFinishedMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const workControllerUploadWorkImage = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append('data', )

      return customInstance<void>(
      {url: `/work/upload-work-image/${id}`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getWorkControllerUploadWorkImageMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerUploadWorkImage>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof workControllerUploadWorkImage>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof workControllerUploadWorkImage>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  workControllerUploadWorkImage(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WorkControllerUploadWorkImageMutationResult = NonNullable<Awaited<ReturnType<typeof workControllerUploadWorkImage>>>
    
    export type WorkControllerUploadWorkImageMutationError = ErrorType<unknown>

    export const useWorkControllerUploadWorkImage = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerUploadWorkImage>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof workControllerUploadWorkImage>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getWorkControllerUploadWorkImageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const workControllerListUserWorks = (
    params?: WorkControllerListUserWorksParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkHttp[]>(
      {url: `/work/list`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getWorkControllerListUserWorksQueryKey = (params?: WorkControllerListUserWorksParams,) => {
    return [`/work/list`, ...(params ? [params]: [])] as const;
    }

    
export const getWorkControllerListUserWorksInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof workControllerListUserWorks>>, WorkControllerListUserWorksParams['page']>, TError = ErrorType<unknown>>(params?: WorkControllerListUserWorksParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorks>>, TError, TData, Awaited<ReturnType<typeof workControllerListUserWorks>>, QueryKey, WorkControllerListUserWorksParams['page']>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerListUserWorksQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerListUserWorks>>, QueryKey, WorkControllerListUserWorksParams['page']> = ({ signal, pageParam }) => workControllerListUserWorks({...params, page: pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorks>>, TError, TData, Awaited<ReturnType<typeof workControllerListUserWorks>>, QueryKey, WorkControllerListUserWorksParams['page']> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerListUserWorksInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerListUserWorks>>>
export type WorkControllerListUserWorksInfiniteQueryError = ErrorType<unknown>


export function useWorkControllerListUserWorksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerListUserWorks>>, WorkControllerListUserWorksParams['page']>, TError = ErrorType<unknown>>(
 params: undefined |  WorkControllerListUserWorksParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorks>>, TError, TData, Awaited<ReturnType<typeof workControllerListUserWorks>>, QueryKey, WorkControllerListUserWorksParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerListUserWorks>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerListUserWorksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerListUserWorks>>, WorkControllerListUserWorksParams['page']>, TError = ErrorType<unknown>>(
 params?: WorkControllerListUserWorksParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorks>>, TError, TData, Awaited<ReturnType<typeof workControllerListUserWorks>>, QueryKey, WorkControllerListUserWorksParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerListUserWorks>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerListUserWorksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerListUserWorks>>, WorkControllerListUserWorksParams['page']>, TError = ErrorType<unknown>>(
 params?: WorkControllerListUserWorksParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorks>>, TError, TData, Awaited<ReturnType<typeof workControllerListUserWorks>>, QueryKey, WorkControllerListUserWorksParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerListUserWorksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerListUserWorks>>, WorkControllerListUserWorksParams['page']>, TError = ErrorType<unknown>>(
 params?: WorkControllerListUserWorksParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorks>>, TError, TData, Awaited<ReturnType<typeof workControllerListUserWorks>>, QueryKey, WorkControllerListUserWorksParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerListUserWorksInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getWorkControllerListUserWorksQueryOptions = <TData = Awaited<ReturnType<typeof workControllerListUserWorks>>, TError = ErrorType<unknown>>(params?: WorkControllerListUserWorksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorks>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerListUserWorksQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerListUserWorks>>> = ({ signal }) => workControllerListUserWorks(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerListUserWorksQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerListUserWorks>>>
export type WorkControllerListUserWorksQueryError = ErrorType<unknown>


export function useWorkControllerListUserWorks<TData = Awaited<ReturnType<typeof workControllerListUserWorks>>, TError = ErrorType<unknown>>(
 params: undefined |  WorkControllerListUserWorksParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerListUserWorks>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerListUserWorks<TData = Awaited<ReturnType<typeof workControllerListUserWorks>>, TError = ErrorType<unknown>>(
 params?: WorkControllerListUserWorksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerListUserWorks>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerListUserWorks<TData = Awaited<ReturnType<typeof workControllerListUserWorks>>, TError = ErrorType<unknown>>(
 params?: WorkControllerListUserWorksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorks>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerListUserWorks<TData = Awaited<ReturnType<typeof workControllerListUserWorks>>, TError = ErrorType<unknown>>(
 params?: WorkControllerListUserWorksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorks>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerListUserWorksQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const workControllerListUserWorksPaged = (
    params: WorkControllerListUserWorksPagedParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkModelPaged>(
      {url: `/work/list/paged`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getWorkControllerListUserWorksPagedQueryKey = (params: WorkControllerListUserWorksPagedParams,) => {
    return [`/work/list/paged`, ...(params ? [params]: [])] as const;
    }

    
export const getWorkControllerListUserWorksPagedInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, WorkControllerListUserWorksPagedParams['page']>, TError = ErrorType<unknown>>(params: WorkControllerListUserWorksPagedParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError, TData, Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, QueryKey, WorkControllerListUserWorksPagedParams['page']>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerListUserWorksPagedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, QueryKey, WorkControllerListUserWorksPagedParams['page']> = ({ signal, pageParam }) => workControllerListUserWorksPaged({...params, page: pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError, TData, Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, QueryKey, WorkControllerListUserWorksPagedParams['page']> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerListUserWorksPagedInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>>
export type WorkControllerListUserWorksPagedInfiniteQueryError = ErrorType<unknown>


export function useWorkControllerListUserWorksPagedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, WorkControllerListUserWorksPagedParams['page']>, TError = ErrorType<unknown>>(
 params: WorkControllerListUserWorksPagedParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError, TData, Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, QueryKey, WorkControllerListUserWorksPagedParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerListUserWorksPaged>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerListUserWorksPagedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, WorkControllerListUserWorksPagedParams['page']>, TError = ErrorType<unknown>>(
 params: WorkControllerListUserWorksPagedParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError, TData, Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, QueryKey, WorkControllerListUserWorksPagedParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerListUserWorksPaged>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerListUserWorksPagedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, WorkControllerListUserWorksPagedParams['page']>, TError = ErrorType<unknown>>(
 params: WorkControllerListUserWorksPagedParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError, TData, Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, QueryKey, WorkControllerListUserWorksPagedParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerListUserWorksPagedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, WorkControllerListUserWorksPagedParams['page']>, TError = ErrorType<unknown>>(
 params: WorkControllerListUserWorksPagedParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError, TData, Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, QueryKey, WorkControllerListUserWorksPagedParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerListUserWorksPagedInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getWorkControllerListUserWorksPagedQueryOptions = <TData = Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError = ErrorType<unknown>>(params: WorkControllerListUserWorksPagedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerListUserWorksPagedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>> = ({ signal }) => workControllerListUserWorksPaged(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerListUserWorksPagedQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>>
export type WorkControllerListUserWorksPagedQueryError = ErrorType<unknown>


export function useWorkControllerListUserWorksPaged<TData = Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError = ErrorType<unknown>>(
 params: WorkControllerListUserWorksPagedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerListUserWorksPaged>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerListUserWorksPaged<TData = Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError = ErrorType<unknown>>(
 params: WorkControllerListUserWorksPagedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerListUserWorksPaged>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerListUserWorksPaged<TData = Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError = ErrorType<unknown>>(
 params: WorkControllerListUserWorksPagedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerListUserWorksPaged<TData = Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError = ErrorType<unknown>>(
 params: WorkControllerListUserWorksPagedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerListUserWorksPaged>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerListUserWorksPagedQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const workControllerToggleFavorite = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/work/${id}/toggle-favorite`, method: 'PATCH'
    },
      options);
    }
  


export const getWorkControllerToggleFavoriteMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerToggleFavorite>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof workControllerToggleFavorite>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof workControllerToggleFavorite>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  workControllerToggleFavorite(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WorkControllerToggleFavoriteMutationResult = NonNullable<Awaited<ReturnType<typeof workControllerToggleFavorite>>>
    
    export type WorkControllerToggleFavoriteMutationError = ErrorType<unknown>

    export const useWorkControllerToggleFavorite = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerToggleFavorite>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof workControllerToggleFavorite>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getWorkControllerToggleFavoriteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const workControllerFetchWorksFavorites = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkHttp[]>(
      {url: `/work/favorites`, method: 'GET', signal
    },
      options);
    }
  

export const getWorkControllerFetchWorksFavoritesQueryKey = () => {
    return [`/work/favorites`] as const;
    }

    
export const getWorkControllerFetchWorksFavoritesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerFetchWorksFavoritesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>> = ({ signal }) => workControllerFetchWorksFavorites(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerFetchWorksFavoritesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>>
export type WorkControllerFetchWorksFavoritesInfiniteQueryError = ErrorType<unknown>


export function useWorkControllerFetchWorksFavoritesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerFetchWorksFavoritesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerFetchWorksFavoritesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerFetchWorksFavoritesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerFetchWorksFavoritesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getWorkControllerFetchWorksFavoritesQueryOptions = <TData = Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWorkControllerFetchWorksFavoritesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>> = ({ signal }) => workControllerFetchWorksFavorites(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type WorkControllerFetchWorksFavoritesQueryResult = NonNullable<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>>
export type WorkControllerFetchWorksFavoritesQueryError = ErrorType<unknown>


export function useWorkControllerFetchWorksFavorites<TData = Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerFetchWorksFavorites<TData = Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useWorkControllerFetchWorksFavorites<TData = Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useWorkControllerFetchWorksFavorites<TData = Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof workControllerFetchWorksFavorites>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getWorkControllerFetchWorksFavoritesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const workControllerGetUploadUrl = (
    getWorkUploadUrlDto: BodyType<GetWorkUploadUrlDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkUploadUrlResponseModel>(
      {url: `/work/upload/get-upload-url`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: getWorkUploadUrlDto, signal
    },
      options);
    }
  


export const getWorkControllerGetUploadUrlMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerGetUploadUrl>>, TError,{data: BodyType<GetWorkUploadUrlDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof workControllerGetUploadUrl>>, TError,{data: BodyType<GetWorkUploadUrlDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof workControllerGetUploadUrl>>, {data: BodyType<GetWorkUploadUrlDto>}> = (props) => {
          const {data} = props ?? {};

          return  workControllerGetUploadUrl(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WorkControllerGetUploadUrlMutationResult = NonNullable<Awaited<ReturnType<typeof workControllerGetUploadUrl>>>
    export type WorkControllerGetUploadUrlMutationBody = BodyType<GetWorkUploadUrlDto>
    export type WorkControllerGetUploadUrlMutationError = ErrorType<unknown>

    export const useWorkControllerGetUploadUrl = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof workControllerGetUploadUrl>>, TError,{data: BodyType<GetWorkUploadUrlDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof workControllerGetUploadUrl>>,
        TError,
        {data: BodyType<GetWorkUploadUrlDto>},
        TContext
      > => {

      const mutationOptions = getWorkControllerGetUploadUrlMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerRegister = (
    createUserDto: BodyType<CreateUserDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createUserDto, signal
    },
      options);
    }
  


export const getAuthControllerRegisterMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,{data: BodyType<CreateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,{data: BodyType<CreateUserDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRegister>>, {data: BodyType<CreateUserDto>}> = (props) => {
          const {data} = props ?? {};

          return  authControllerRegister(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRegister>>>
    export type AuthControllerRegisterMutationBody = BodyType<CreateUserDto>
    export type AuthControllerRegisterMutationError = ErrorType<unknown>

    export const useAuthControllerRegister = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,{data: BodyType<CreateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRegister>>,
        TError,
        {data: BodyType<CreateUserDto>},
        TContext
      > => {

      const mutationOptions = getAuthControllerRegisterMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerLoginV2 = (
    makeSessionValidator: BodyType<MakeSessionValidator>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/v2/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: makeSessionValidator, signal
    },
      options);
    }
  


export const getAuthControllerLoginV2MutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLoginV2>>, TError,{data: BodyType<MakeSessionValidator>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLoginV2>>, TError,{data: BodyType<MakeSessionValidator>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLoginV2>>, {data: BodyType<MakeSessionValidator>}> = (props) => {
          const {data} = props ?? {};

          return  authControllerLoginV2(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLoginV2MutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLoginV2>>>
    export type AuthControllerLoginV2MutationBody = BodyType<MakeSessionValidator>
    export type AuthControllerLoginV2MutationError = ErrorType<unknown>

    export const useAuthControllerLoginV2 = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLoginV2>>, TError,{data: BodyType<MakeSessionValidator>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLoginV2>>,
        TError,
        {data: BodyType<MakeSessionValidator>},
        TContext
      > => {

      const mutationOptions = getAuthControllerLoginV2MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerRefreshToken = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/v2/refresh-token`, method: 'POST', signal
    },
      options);
    }
  


export const getAuthControllerRefreshTokenMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRefreshToken>>, void> = () => {
          

          return  authControllerRefreshToken(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRefreshTokenMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRefreshToken>>>
    
    export type AuthControllerRefreshTokenMutationError = ErrorType<unknown>

    export const useAuthControllerRefreshToken = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRefreshToken>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthControllerRefreshTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerLoginV2Mobile = (
    makeSessionValidator: BodyType<MakeSessionValidator>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RefreshTokenModel>(
      {url: `/auth/v2/login/mobile`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: makeSessionValidator, signal
    },
      options);
    }
  


export const getAuthControllerLoginV2MobileMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLoginV2Mobile>>, TError,{data: BodyType<MakeSessionValidator>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLoginV2Mobile>>, TError,{data: BodyType<MakeSessionValidator>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLoginV2Mobile>>, {data: BodyType<MakeSessionValidator>}> = (props) => {
          const {data} = props ?? {};

          return  authControllerLoginV2Mobile(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLoginV2MobileMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLoginV2Mobile>>>
    export type AuthControllerLoginV2MobileMutationBody = BodyType<MakeSessionValidator>
    export type AuthControllerLoginV2MobileMutationError = ErrorType<unknown>

    export const useAuthControllerLoginV2Mobile = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLoginV2Mobile>>, TError,{data: BodyType<MakeSessionValidator>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLoginV2Mobile>>,
        TError,
        {data: BodyType<MakeSessionValidator>},
        TContext
      > => {

      const mutationOptions = getAuthControllerLoginV2MobileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerRefreshTokenMobile = (
    refreshTokenDto: BodyType<RefreshTokenDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RefreshTokenOnlyModel>(
      {url: `/auth/v2/refresh-token/mobile`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshTokenDto, signal
    },
      options);
    }
  


export const getAuthControllerRefreshTokenMobileMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRefreshTokenMobile>>, TError,{data: BodyType<RefreshTokenDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRefreshTokenMobile>>, TError,{data: BodyType<RefreshTokenDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRefreshTokenMobile>>, {data: BodyType<RefreshTokenDto>}> = (props) => {
          const {data} = props ?? {};

          return  authControllerRefreshTokenMobile(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRefreshTokenMobileMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRefreshTokenMobile>>>
    export type AuthControllerRefreshTokenMobileMutationBody = BodyType<RefreshTokenDto>
    export type AuthControllerRefreshTokenMobileMutationError = ErrorType<unknown>

    export const useAuthControllerRefreshTokenMobile = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRefreshTokenMobile>>, TError,{data: BodyType<RefreshTokenDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRefreshTokenMobile>>,
        TError,
        {data: BodyType<RefreshTokenDto>},
        TContext
      > => {

      const mutationOptions = getAuthControllerRefreshTokenMobileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerCheckSession = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/v2/check-session`, method: 'GET', signal
    },
      options);
    }
  

export const getAuthControllerCheckSessionQueryKey = () => {
    return [`/auth/v2/check-session`] as const;
    }

    
export const getAuthControllerCheckSessionInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerCheckSession>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerCheckSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerCheckSessionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerCheckSession>>> = ({ signal }) => authControllerCheckSession(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerCheckSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AuthControllerCheckSessionInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerCheckSession>>>
export type AuthControllerCheckSessionInfiniteQueryError = ErrorType<unknown>


export function useAuthControllerCheckSessionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerCheckSession>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerCheckSession>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerCheckSession>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerCheckSessionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerCheckSession>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerCheckSession>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerCheckSession>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerCheckSessionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerCheckSession>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerCheckSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useAuthControllerCheckSessionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerCheckSession>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerCheckSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAuthControllerCheckSessionInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAuthControllerCheckSessionQueryOptions = <TData = Awaited<ReturnType<typeof authControllerCheckSession>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerCheckSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerCheckSessionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerCheckSession>>> = ({ signal }) => authControllerCheckSession(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerCheckSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AuthControllerCheckSessionQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerCheckSession>>>
export type AuthControllerCheckSessionQueryError = ErrorType<unknown>


export function useAuthControllerCheckSession<TData = Awaited<ReturnType<typeof authControllerCheckSession>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerCheckSession>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerCheckSession>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerCheckSession<TData = Awaited<ReturnType<typeof authControllerCheckSession>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerCheckSession>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerCheckSession>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerCheckSession<TData = Awaited<ReturnType<typeof authControllerCheckSession>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerCheckSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useAuthControllerCheckSession<TData = Awaited<ReturnType<typeof authControllerCheckSession>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerCheckSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAuthControllerCheckSessionQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const authControllerUploadAvatarImage = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append('data', )

      return customInstance<void>(
      {url: `/auth/user/avatar/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getAuthControllerUploadAvatarImageMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerUploadAvatarImage>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerUploadAvatarImage>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerUploadAvatarImage>>, void> = () => {
          

          return  authControllerUploadAvatarImage(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerUploadAvatarImageMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerUploadAvatarImage>>>
    
    export type AuthControllerUploadAvatarImageMutationError = ErrorType<unknown>

    export const useAuthControllerUploadAvatarImage = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerUploadAvatarImage>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerUploadAvatarImage>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthControllerUploadAvatarImageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerGetMe = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserHttp>(
      {url: `/auth/user/me`, method: 'GET', signal
    },
      options);
    }
  

export const getAuthControllerGetMeQueryKey = () => {
    return [`/auth/user/me`] as const;
    }

    
export const getAuthControllerGetMeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetMe>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetMe>>> = ({ signal }) => authControllerGetMe(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AuthControllerGetMeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetMe>>>
export type AuthControllerGetMeInfiniteQueryError = ErrorType<unknown>


export function useAuthControllerGetMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetMe>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetMe>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerGetMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetMe>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetMe>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerGetMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetMe>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useAuthControllerGetMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetMe>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAuthControllerGetMeInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAuthControllerGetMeQueryOptions = <TData = Awaited<ReturnType<typeof authControllerGetMe>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetMe>>> = ({ signal }) => authControllerGetMe(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AuthControllerGetMeQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetMe>>>
export type AuthControllerGetMeQueryError = ErrorType<unknown>


export function useAuthControllerGetMe<TData = Awaited<ReturnType<typeof authControllerGetMe>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetMe>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerGetMe<TData = Awaited<ReturnType<typeof authControllerGetMe>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetMe>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerGetMe<TData = Awaited<ReturnType<typeof authControllerGetMe>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useAuthControllerGetMe<TData = Awaited<ReturnType<typeof authControllerGetMe>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAuthControllerGetMeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const authControllerCreateAccessToken = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AccessToken>(
      {url: `/auth/access-token`, method: 'POST', signal
    },
      options);
    }
  


export const getAuthControllerCreateAccessTokenMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerCreateAccessToken>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerCreateAccessToken>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerCreateAccessToken>>, void> = () => {
          

          return  authControllerCreateAccessToken(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerCreateAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerCreateAccessToken>>>
    
    export type AuthControllerCreateAccessTokenMutationError = ErrorType<unknown>

    export const useAuthControllerCreateAccessToken = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerCreateAccessToken>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerCreateAccessToken>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthControllerCreateAccessTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerCreateAdminHashCode = (
    createAdminHashCodeDto: BodyType<CreateAdminHashCodeDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/admin-hash-code`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAdminHashCodeDto, signal
    },
      options);
    }
  


export const getAuthControllerCreateAdminHashCodeMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerCreateAdminHashCode>>, TError,{data: BodyType<CreateAdminHashCodeDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerCreateAdminHashCode>>, TError,{data: BodyType<CreateAdminHashCodeDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerCreateAdminHashCode>>, {data: BodyType<CreateAdminHashCodeDto>}> = (props) => {
          const {data} = props ?? {};

          return  authControllerCreateAdminHashCode(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerCreateAdminHashCodeMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerCreateAdminHashCode>>>
    export type AuthControllerCreateAdminHashCodeMutationBody = BodyType<CreateAdminHashCodeDto>
    export type AuthControllerCreateAdminHashCodeMutationError = ErrorType<unknown>

    export const useAuthControllerCreateAdminHashCode = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerCreateAdminHashCode>>, TError,{data: BodyType<CreateAdminHashCodeDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerCreateAdminHashCode>>,
        TError,
        {data: BodyType<CreateAdminHashCodeDto>},
        TContext
      > => {

      const mutationOptions = getAuthControllerCreateAdminHashCodeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerResetPassword = (
    resetPasswordDto: BodyType<ResetPasswordDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/reset-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resetPasswordDto, signal
    },
      options);
    }
  


export const getAuthControllerResetPasswordMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerResetPassword>>, TError,{data: BodyType<ResetPasswordDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerResetPassword>>, TError,{data: BodyType<ResetPasswordDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerResetPassword>>, {data: BodyType<ResetPasswordDto>}> = (props) => {
          const {data} = props ?? {};

          return  authControllerResetPassword(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerResetPassword>>>
    export type AuthControllerResetPasswordMutationBody = BodyType<ResetPasswordDto>
    export type AuthControllerResetPasswordMutationError = ErrorType<unknown>

    export const useAuthControllerResetPassword = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerResetPassword>>, TError,{data: BodyType<ResetPasswordDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerResetPassword>>,
        TError,
        {data: BodyType<ResetPasswordDto>},
        TContext
      > => {

      const mutationOptions = getAuthControllerResetPasswordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerLogout = (
    logoutDto: BodyType<LogoutDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/logout`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: logoutDto, signal
    },
      options);
    }
  


export const getAuthControllerLogoutMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,{data: BodyType<LogoutDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,{data: BodyType<LogoutDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogout>>, {data: BodyType<LogoutDto>}> = (props) => {
          const {data} = props ?? {};

          return  authControllerLogout(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogout>>>
    export type AuthControllerLogoutMutationBody = BodyType<LogoutDto>
    export type AuthControllerLogoutMutationError = ErrorType<unknown>

    export const useAuthControllerLogout = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,{data: BodyType<LogoutDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogout>>,
        TError,
        {data: BodyType<LogoutDto>},
        TContext
      > => {

      const mutationOptions = getAuthControllerLogoutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerUpdateNotionDatabaseId = (
    updateNotionDatabaseIdDto: BodyType<UpdateNotionDatabaseIdDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/notion/update-database-id`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: updateNotionDatabaseIdDto, signal
    },
      options);
    }
  


export const getAuthControllerUpdateNotionDatabaseIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerUpdateNotionDatabaseId>>, TError,{data: BodyType<UpdateNotionDatabaseIdDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerUpdateNotionDatabaseId>>, TError,{data: BodyType<UpdateNotionDatabaseIdDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerUpdateNotionDatabaseId>>, {data: BodyType<UpdateNotionDatabaseIdDto>}> = (props) => {
          const {data} = props ?? {};

          return  authControllerUpdateNotionDatabaseId(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerUpdateNotionDatabaseIdMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerUpdateNotionDatabaseId>>>
    export type AuthControllerUpdateNotionDatabaseIdMutationBody = BodyType<UpdateNotionDatabaseIdDto>
    export type AuthControllerUpdateNotionDatabaseIdMutationError = ErrorType<unknown>

    export const useAuthControllerUpdateNotionDatabaseId = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerUpdateNotionDatabaseId>>, TError,{data: BodyType<UpdateNotionDatabaseIdDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerUpdateNotionDatabaseId>>,
        TError,
        {data: BodyType<UpdateNotionDatabaseIdDto>},
        TContext
      > => {

      const mutationOptions = getAuthControllerUpdateNotionDatabaseIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerFetchUserAnalytics = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/user/analytics`, method: 'GET', signal
    },
      options);
    }
  

export const getAuthControllerFetchUserAnalyticsQueryKey = () => {
    return [`/auth/user/analytics`] as const;
    }

    
export const getAuthControllerFetchUserAnalyticsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerFetchUserAnalyticsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>> = ({ signal }) => authControllerFetchUserAnalytics(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AuthControllerFetchUserAnalyticsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>>
export type AuthControllerFetchUserAnalyticsInfiniteQueryError = ErrorType<unknown>


export function useAuthControllerFetchUserAnalyticsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerFetchUserAnalyticsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerFetchUserAnalyticsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useAuthControllerFetchUserAnalyticsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAuthControllerFetchUserAnalyticsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAuthControllerFetchUserAnalyticsQueryOptions = <TData = Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerFetchUserAnalyticsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>> = ({ signal }) => authControllerFetchUserAnalytics(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AuthControllerFetchUserAnalyticsQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>>
export type AuthControllerFetchUserAnalyticsQueryError = ErrorType<unknown>


export function useAuthControllerFetchUserAnalytics<TData = Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerFetchUserAnalytics<TData = Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerFetchUserAnalytics<TData = Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useAuthControllerFetchUserAnalytics<TData = Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAuthControllerFetchUserAnalyticsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const authControllerGetUserTrialQuoteGet = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/user/trial-quote`, method: 'GET', signal
    },
      options);
    }
  

export const getAuthControllerGetUserTrialQuoteGetQueryKey = () => {
    return [`/auth/user/trial-quote`] as const;
    }

    
export const getAuthControllerGetUserTrialQuoteGetInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerGetUserTrialQuoteGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>> = ({ signal }) => authControllerGetUserTrialQuoteGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AuthControllerGetUserTrialQuoteGetInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>>
export type AuthControllerGetUserTrialQuoteGetInfiniteQueryError = ErrorType<unknown>


export function useAuthControllerGetUserTrialQuoteGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerGetUserTrialQuoteGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerGetUserTrialQuoteGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useAuthControllerGetUserTrialQuoteGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAuthControllerGetUserTrialQuoteGetInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAuthControllerGetUserTrialQuoteGetQueryOptions = <TData = Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerGetUserTrialQuoteGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>> = ({ signal }) => authControllerGetUserTrialQuoteGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AuthControllerGetUserTrialQuoteGetQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>>
export type AuthControllerGetUserTrialQuoteGetQueryError = ErrorType<unknown>


export function useAuthControllerGetUserTrialQuoteGet<TData = Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerGetUserTrialQuoteGet<TData = Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerGetUserTrialQuoteGet<TData = Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useAuthControllerGetUserTrialQuoteGet<TData = Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAuthControllerGetUserTrialQuoteGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const authControllerGetTelegramStatus = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/user/telegram-status`, method: 'GET', signal
    },
      options);
    }
  

export const getAuthControllerGetTelegramStatusQueryKey = () => {
    return [`/auth/user/telegram-status`] as const;
    }

    
export const getAuthControllerGetTelegramStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerGetTelegramStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>> = ({ signal }) => authControllerGetTelegramStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AuthControllerGetTelegramStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>>
export type AuthControllerGetTelegramStatusInfiniteQueryError = ErrorType<unknown>


export function useAuthControllerGetTelegramStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetTelegramStatus>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerGetTelegramStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetTelegramStatus>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerGetTelegramStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useAuthControllerGetTelegramStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAuthControllerGetTelegramStatusInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAuthControllerGetTelegramStatusQueryOptions = <TData = Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerGetTelegramStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>> = ({ signal }) => authControllerGetTelegramStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AuthControllerGetTelegramStatusQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>>
export type AuthControllerGetTelegramStatusQueryError = ErrorType<unknown>


export function useAuthControllerGetTelegramStatus<TData = Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetTelegramStatus>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerGetTelegramStatus<TData = Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetTelegramStatus>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuthControllerGetTelegramStatus<TData = Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useAuthControllerGetTelegramStatus<TData = Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAuthControllerGetTelegramStatusQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const authControllerSendResetPasswordEmail = (
    sendResetPasswordEmailDto: BodyType<SendResetPasswordEmailDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/password/send-reset-email`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sendResetPasswordEmailDto, signal
    },
      options);
    }
  


export const getAuthControllerSendResetPasswordEmailMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSendResetPasswordEmail>>, TError,{data: BodyType<SendResetPasswordEmailDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerSendResetPasswordEmail>>, TError,{data: BodyType<SendResetPasswordEmailDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerSendResetPasswordEmail>>, {data: BodyType<SendResetPasswordEmailDto>}> = (props) => {
          const {data} = props ?? {};

          return  authControllerSendResetPasswordEmail(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerSendResetPasswordEmailMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerSendResetPasswordEmail>>>
    export type AuthControllerSendResetPasswordEmailMutationBody = BodyType<SendResetPasswordEmailDto>
    export type AuthControllerSendResetPasswordEmailMutationError = ErrorType<unknown>

    export const useAuthControllerSendResetPasswordEmail = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSendResetPasswordEmail>>, TError,{data: BodyType<SendResetPasswordEmailDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerSendResetPasswordEmail>>,
        TError,
        {data: BodyType<SendResetPasswordEmailDto>},
        TContext
      > => {

      const mutationOptions = getAuthControllerSendResetPasswordEmailMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerResetUserPassword = (
    resetUserPasswordDto: BodyType<ResetUserPasswordDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/password/reset`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resetUserPasswordDto, signal
    },
      options);
    }
  


export const getAuthControllerResetUserPasswordMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerResetUserPassword>>, TError,{data: BodyType<ResetUserPasswordDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerResetUserPassword>>, TError,{data: BodyType<ResetUserPasswordDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerResetUserPassword>>, {data: BodyType<ResetUserPasswordDto>}> = (props) => {
          const {data} = props ?? {};

          return  authControllerResetUserPassword(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerResetUserPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerResetUserPassword>>>
    export type AuthControllerResetUserPasswordMutationBody = BodyType<ResetUserPasswordDto>
    export type AuthControllerResetUserPasswordMutationError = ErrorType<unknown>

    export const useAuthControllerResetUserPassword = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerResetUserPassword>>, TError,{data: BodyType<ResetUserPasswordDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerResetUserPassword>>,
        TError,
        {data: BodyType<ResetUserPasswordDto>},
        TContext
      > => {

      const mutationOptions = getAuthControllerResetUserPasswordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerUpdateUser = (
    updateUserDto: BodyType<UpdateUserDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/auth/user`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateUserDto
    },
      options);
    }
  


export const getAuthControllerUpdateUserMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerUpdateUser>>, TError,{data: BodyType<UpdateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerUpdateUser>>, TError,{data: BodyType<UpdateUserDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerUpdateUser>>, {data: BodyType<UpdateUserDto>}> = (props) => {
          const {data} = props ?? {};

          return  authControllerUpdateUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerUpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerUpdateUser>>>
    export type AuthControllerUpdateUserMutationBody = BodyType<UpdateUserDto>
    export type AuthControllerUpdateUserMutationError = ErrorType<unknown>

    export const useAuthControllerUpdateUser = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerUpdateUser>>, TError,{data: BodyType<UpdateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerUpdateUser>>,
        TError,
        {data: BodyType<UpdateUserDto>},
        TContext
      > => {

      const mutationOptions = getAuthControllerUpdateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerSendConfirmEmail = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/user/send-confirm-email`, method: 'POST', signal
    },
      options);
    }
  


export const getAuthControllerSendConfirmEmailMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSendConfirmEmail>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerSendConfirmEmail>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerSendConfirmEmail>>, void> = () => {
          

          return  authControllerSendConfirmEmail(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerSendConfirmEmailMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerSendConfirmEmail>>>
    
    export type AuthControllerSendConfirmEmailMutationError = ErrorType<unknown>

    export const useAuthControllerSendConfirmEmail = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSendConfirmEmail>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerSendConfirmEmail>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthControllerSendConfirmEmailMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const authControllerValidateEmailCode = (
    validateEmailDto: BodyType<ValidateEmailDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/user/validate-email`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: validateEmailDto, signal
    },
      options);
    }
  


export const getAuthControllerValidateEmailCodeMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerValidateEmailCode>>, TError,{data: BodyType<ValidateEmailDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerValidateEmailCode>>, TError,{data: BodyType<ValidateEmailDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerValidateEmailCode>>, {data: BodyType<ValidateEmailDto>}> = (props) => {
          const {data} = props ?? {};

          return  authControllerValidateEmailCode(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerValidateEmailCodeMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerValidateEmailCode>>>
    export type AuthControllerValidateEmailCodeMutationBody = BodyType<ValidateEmailDto>
    export type AuthControllerValidateEmailCodeMutationError = ErrorType<unknown>

    export const useAuthControllerValidateEmailCode = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerValidateEmailCode>>, TError,{data: BodyType<ValidateEmailDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerValidateEmailCode>>,
        TError,
        {data: BodyType<ValidateEmailDto>},
        TContext
      > => {

      const mutationOptions = getAuthControllerValidateEmailCodeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const notificationControllerSubscribeInMobile = (
    registerMobilePushSubscriberDto: BodyType<RegisterMobilePushSubscriberDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/notification/push/mobile/subscribe`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerMobilePushSubscriberDto, signal
    },
      options);
    }
  


export const getNotificationControllerSubscribeInMobileMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationControllerSubscribeInMobile>>, TError,{data: BodyType<RegisterMobilePushSubscriberDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof notificationControllerSubscribeInMobile>>, TError,{data: BodyType<RegisterMobilePushSubscriberDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof notificationControllerSubscribeInMobile>>, {data: BodyType<RegisterMobilePushSubscriberDto>}> = (props) => {
          const {data} = props ?? {};

          return  notificationControllerSubscribeInMobile(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NotificationControllerSubscribeInMobileMutationResult = NonNullable<Awaited<ReturnType<typeof notificationControllerSubscribeInMobile>>>
    export type NotificationControllerSubscribeInMobileMutationBody = BodyType<RegisterMobilePushSubscriberDto>
    export type NotificationControllerSubscribeInMobileMutationError = ErrorType<unknown>

    export const useNotificationControllerSubscribeInMobile = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationControllerSubscribeInMobile>>, TError,{data: BodyType<RegisterMobilePushSubscriberDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof notificationControllerSubscribeInMobile>>,
        TError,
        {data: BodyType<RegisterMobilePushSubscriberDto>},
        TContext
      > => {

      const mutationOptions = getNotificationControllerSubscribeInMobileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const notificationControllerGetRecentNotifications = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NotificationHttp[]>(
      {url: `/notification/recent`, method: 'GET', signal
    },
      options);
    }
  

export const getNotificationControllerGetRecentNotificationsQueryKey = () => {
    return [`/notification/recent`] as const;
    }

    
export const getNotificationControllerGetRecentNotificationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNotificationControllerGetRecentNotificationsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>> = ({ signal }) => notificationControllerGetRecentNotifications(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type NotificationControllerGetRecentNotificationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>>
export type NotificationControllerGetRecentNotificationsInfiniteQueryError = ErrorType<unknown>


export function useNotificationControllerGetRecentNotificationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationControllerGetRecentNotificationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationControllerGetRecentNotificationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useNotificationControllerGetRecentNotificationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getNotificationControllerGetRecentNotificationsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getNotificationControllerGetRecentNotificationsQueryOptions = <TData = Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNotificationControllerGetRecentNotificationsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>> = ({ signal }) => notificationControllerGetRecentNotifications(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type NotificationControllerGetRecentNotificationsQueryResult = NonNullable<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>>
export type NotificationControllerGetRecentNotificationsQueryError = ErrorType<unknown>


export function useNotificationControllerGetRecentNotifications<TData = Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationControllerGetRecentNotifications<TData = Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationControllerGetRecentNotifications<TData = Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useNotificationControllerGetRecentNotifications<TData = Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationControllerGetRecentNotifications>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getNotificationControllerGetRecentNotificationsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const notificationControllerMarkNotificationAsRead = (
    notificationId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/notification/mark-read/${notificationId}`, method: 'POST', signal
    },
      options);
    }
  


export const getNotificationControllerMarkNotificationAsReadMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationControllerMarkNotificationAsRead>>, TError,{notificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof notificationControllerMarkNotificationAsRead>>, TError,{notificationId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof notificationControllerMarkNotificationAsRead>>, {notificationId: string}> = (props) => {
          const {notificationId} = props ?? {};

          return  notificationControllerMarkNotificationAsRead(notificationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NotificationControllerMarkNotificationAsReadMutationResult = NonNullable<Awaited<ReturnType<typeof notificationControllerMarkNotificationAsRead>>>
    
    export type NotificationControllerMarkNotificationAsReadMutationError = ErrorType<unknown>

    export const useNotificationControllerMarkNotificationAsRead = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationControllerMarkNotificationAsRead>>, TError,{notificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof notificationControllerMarkNotificationAsRead>>,
        TError,
        {notificationId: string},
        TContext
      > => {

      const mutationOptions = getNotificationControllerMarkNotificationAsReadMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const notificationControllerUpdateChatId = (
    updateTelegramChatIdValidator: BodyType<UpdateTelegramChatIdValidator>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/notification/telegram/update-chat-id`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateTelegramChatIdValidator
    },
      options);
    }
  


export const getNotificationControllerUpdateChatIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationControllerUpdateChatId>>, TError,{data: BodyType<UpdateTelegramChatIdValidator>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof notificationControllerUpdateChatId>>, TError,{data: BodyType<UpdateTelegramChatIdValidator>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof notificationControllerUpdateChatId>>, {data: BodyType<UpdateTelegramChatIdValidator>}> = (props) => {
          const {data} = props ?? {};

          return  notificationControllerUpdateChatId(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NotificationControllerUpdateChatIdMutationResult = NonNullable<Awaited<ReturnType<typeof notificationControllerUpdateChatId>>>
    export type NotificationControllerUpdateChatIdMutationBody = BodyType<UpdateTelegramChatIdValidator>
    export type NotificationControllerUpdateChatIdMutationError = ErrorType<unknown>

    export const useNotificationControllerUpdateChatId = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationControllerUpdateChatId>>, TError,{data: BodyType<UpdateTelegramChatIdValidator>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof notificationControllerUpdateChatId>>,
        TError,
        {data: BodyType<UpdateTelegramChatIdValidator>},
        TContext
      > => {

      const mutationOptions = getNotificationControllerUpdateChatIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const notificationControllerSendAuthCode = (
    sendAuthCodeByEmailValidator: BodyType<SendAuthCodeByEmailValidator>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/notification/telegram/send-auth-code`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sendAuthCodeByEmailValidator, signal
    },
      options);
    }
  


export const getNotificationControllerSendAuthCodeMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationControllerSendAuthCode>>, TError,{data: BodyType<SendAuthCodeByEmailValidator>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof notificationControllerSendAuthCode>>, TError,{data: BodyType<SendAuthCodeByEmailValidator>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof notificationControllerSendAuthCode>>, {data: BodyType<SendAuthCodeByEmailValidator>}> = (props) => {
          const {data} = props ?? {};

          return  notificationControllerSendAuthCode(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NotificationControllerSendAuthCodeMutationResult = NonNullable<Awaited<ReturnType<typeof notificationControllerSendAuthCode>>>
    export type NotificationControllerSendAuthCodeMutationBody = BodyType<SendAuthCodeByEmailValidator>
    export type NotificationControllerSendAuthCodeMutationError = ErrorType<unknown>

    export const useNotificationControllerSendAuthCode = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationControllerSendAuthCode>>, TError,{data: BodyType<SendAuthCodeByEmailValidator>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof notificationControllerSendAuthCode>>,
        TError,
        {data: BodyType<SendAuthCodeByEmailValidator>},
        TContext
      > => {

      const mutationOptions = getNotificationControllerSendAuthCodeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const notificationControllerCompareSubscriberAuthCodeCall = (
    compareSubscriberAuthTokenDto: BodyType<CompareSubscriberAuthTokenDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/notification/telegram/compare-auth-code`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: compareSubscriberAuthTokenDto, signal
    },
      options);
    }
  


export const getNotificationControllerCompareSubscriberAuthCodeCallMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationControllerCompareSubscriberAuthCodeCall>>, TError,{data: BodyType<CompareSubscriberAuthTokenDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof notificationControllerCompareSubscriberAuthCodeCall>>, TError,{data: BodyType<CompareSubscriberAuthTokenDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof notificationControllerCompareSubscriberAuthCodeCall>>, {data: BodyType<CompareSubscriberAuthTokenDto>}> = (props) => {
          const {data} = props ?? {};

          return  notificationControllerCompareSubscriberAuthCodeCall(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NotificationControllerCompareSubscriberAuthCodeCallMutationResult = NonNullable<Awaited<ReturnType<typeof notificationControllerCompareSubscriberAuthCodeCall>>>
    export type NotificationControllerCompareSubscriberAuthCodeCallMutationBody = BodyType<CompareSubscriberAuthTokenDto>
    export type NotificationControllerCompareSubscriberAuthCodeCallMutationError = ErrorType<unknown>

    export const useNotificationControllerCompareSubscriberAuthCodeCall = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationControllerCompareSubscriberAuthCodeCall>>, TError,{data: BodyType<CompareSubscriberAuthTokenDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof notificationControllerCompareSubscriberAuthCodeCall>>,
        TError,
        {data: BodyType<CompareSubscriberAuthTokenDto>},
        TContext
      > => {

      const mutationOptions = getNotificationControllerCompareSubscriberAuthCodeCallMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const notificationControllerGetSubscriberByEmail = (
    email: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/notification/telegram/find/${email}`, method: 'GET', signal
    },
      options);
    }
  

export const getNotificationControllerGetSubscriberByEmailQueryKey = (email: string,) => {
    return [`/notification/telegram/find/${email}`] as const;
    }

    
export const getNotificationControllerGetSubscriberByEmailInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>>, TError = ErrorType<unknown>>(email: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNotificationControllerGetSubscriberByEmailQueryKey(email);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>> = ({ signal }) => notificationControllerGetSubscriberByEmail(email, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(email), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type NotificationControllerGetSubscriberByEmailInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>>
export type NotificationControllerGetSubscriberByEmailInfiniteQueryError = ErrorType<unknown>


export function useNotificationControllerGetSubscriberByEmailInfinite<TData = InfiniteData<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>>, TError = ErrorType<unknown>>(
 email: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationControllerGetSubscriberByEmailInfinite<TData = InfiniteData<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>>, TError = ErrorType<unknown>>(
 email: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationControllerGetSubscriberByEmailInfinite<TData = InfiniteData<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>>, TError = ErrorType<unknown>>(
 email: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useNotificationControllerGetSubscriberByEmailInfinite<TData = InfiniteData<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>>, TError = ErrorType<unknown>>(
 email: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getNotificationControllerGetSubscriberByEmailInfiniteQueryOptions(email,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getNotificationControllerGetSubscriberByEmailQueryOptions = <TData = Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError = ErrorType<unknown>>(email: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNotificationControllerGetSubscriberByEmailQueryKey(email);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>> = ({ signal }) => notificationControllerGetSubscriberByEmail(email, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(email), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type NotificationControllerGetSubscriberByEmailQueryResult = NonNullable<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>>
export type NotificationControllerGetSubscriberByEmailQueryError = ErrorType<unknown>


export function useNotificationControllerGetSubscriberByEmail<TData = Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError = ErrorType<unknown>>(
 email: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationControllerGetSubscriberByEmail<TData = Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError = ErrorType<unknown>>(
 email: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationControllerGetSubscriberByEmail<TData = Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError = ErrorType<unknown>>(
 email: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useNotificationControllerGetSubscriberByEmail<TData = Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError = ErrorType<unknown>>(
 email: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationControllerGetSubscriberByEmail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getNotificationControllerGetSubscriberByEmailQueryOptions(email,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const notificationControllerSubscribeInWeb = (
    registerWebPushSubscriptionDto: BodyType<RegisterWebPushSubscriptionDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/notification/push/web/subscribe`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerWebPushSubscriptionDto, signal
    },
      options);
    }
  


export const getNotificationControllerSubscribeInWebMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationControllerSubscribeInWeb>>, TError,{data: BodyType<RegisterWebPushSubscriptionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof notificationControllerSubscribeInWeb>>, TError,{data: BodyType<RegisterWebPushSubscriptionDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof notificationControllerSubscribeInWeb>>, {data: BodyType<RegisterWebPushSubscriptionDto>}> = (props) => {
          const {data} = props ?? {};

          return  notificationControllerSubscribeInWeb(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NotificationControllerSubscribeInWebMutationResult = NonNullable<Awaited<ReturnType<typeof notificationControllerSubscribeInWeb>>>
    export type NotificationControllerSubscribeInWebMutationBody = BodyType<RegisterWebPushSubscriptionDto>
    export type NotificationControllerSubscribeInWebMutationError = ErrorType<unknown>

    export const useNotificationControllerSubscribeInWeb = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationControllerSubscribeInWeb>>, TError,{data: BodyType<RegisterWebPushSubscriptionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof notificationControllerSubscribeInWeb>>,
        TError,
        {data: BodyType<RegisterWebPushSubscriptionDto>},
        TContext
      > => {

      const mutationOptions = getNotificationControllerSubscribeInWebMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const paymentControllerCreateIntentPayment = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/payment/checkout`, method: 'POST', signal
    },
      options);
    }
  


export const getPaymentControllerCreateIntentPaymentMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreateIntentPayment>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreateIntentPayment>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentControllerCreateIntentPayment>>, void> = () => {
          

          return  paymentControllerCreateIntentPayment(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentControllerCreateIntentPaymentMutationResult = NonNullable<Awaited<ReturnType<typeof paymentControllerCreateIntentPayment>>>
    
    export type PaymentControllerCreateIntentPaymentMutationError = ErrorType<unknown>

    export const usePaymentControllerCreateIntentPayment = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreateIntentPayment>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof paymentControllerCreateIntentPayment>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPaymentControllerCreateIntentPaymentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const paymentControllerWebhook = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/payment/webhook`, method: 'POST', signal
    },
      options);
    }
  


export const getPaymentControllerWebhookMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerWebhook>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentControllerWebhook>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentControllerWebhook>>, void> = () => {
          

          return  paymentControllerWebhook(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentControllerWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof paymentControllerWebhook>>>
    
    export type PaymentControllerWebhookMutationError = ErrorType<unknown>

    export const usePaymentControllerWebhook = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerWebhook>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof paymentControllerWebhook>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPaymentControllerWebhookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const paymentControllerChecksPaymentSubscriptionStatus = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaymentStatusModel>(
      {url: `/payment/subscription/status`, method: 'GET', signal
    },
      options);
    }
  

export const getPaymentControllerChecksPaymentSubscriptionStatusQueryKey = () => {
    return [`/payment/subscription/status`] as const;
    }

    
export const getPaymentControllerChecksPaymentSubscriptionStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentControllerChecksPaymentSubscriptionStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>> = ({ signal }) => paymentControllerChecksPaymentSubscriptionStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PaymentControllerChecksPaymentSubscriptionStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>>
export type PaymentControllerChecksPaymentSubscriptionStatusInfiniteQueryError = ErrorType<unknown>


export function usePaymentControllerChecksPaymentSubscriptionStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentControllerChecksPaymentSubscriptionStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentControllerChecksPaymentSubscriptionStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function usePaymentControllerChecksPaymentSubscriptionStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPaymentControllerChecksPaymentSubscriptionStatusInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getPaymentControllerChecksPaymentSubscriptionStatusQueryOptions = <TData = Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentControllerChecksPaymentSubscriptionStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>> = ({ signal }) => paymentControllerChecksPaymentSubscriptionStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PaymentControllerChecksPaymentSubscriptionStatusQueryResult = NonNullable<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>>
export type PaymentControllerChecksPaymentSubscriptionStatusQueryError = ErrorType<unknown>


export function usePaymentControllerChecksPaymentSubscriptionStatus<TData = Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentControllerChecksPaymentSubscriptionStatus<TData = Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentControllerChecksPaymentSubscriptionStatus<TData = Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function usePaymentControllerChecksPaymentSubscriptionStatus<TData = Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerChecksPaymentSubscriptionStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPaymentControllerChecksPaymentSubscriptionStatusQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tagControllerCreate = (
    createTagDto: BodyType<CreateTagDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/tags`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTagDto, signal
    },
      options);
    }
  


export const getTagControllerCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagControllerCreate>>, TError,{data: BodyType<CreateTagDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tagControllerCreate>>, TError,{data: BodyType<CreateTagDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagControllerCreate>>, {data: BodyType<CreateTagDto>}> = (props) => {
          const {data} = props ?? {};

          return  tagControllerCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof tagControllerCreate>>>
    export type TagControllerCreateMutationBody = BodyType<CreateTagDto>
    export type TagControllerCreateMutationError = ErrorType<unknown>

    export const useTagControllerCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagControllerCreate>>, TError,{data: BodyType<CreateTagDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof tagControllerCreate>>,
        TError,
        {data: BodyType<CreateTagDto>},
        TContext
      > => {

      const mutationOptions = getTagControllerCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const tagControllerListTags = (
    params: TagControllerListTagsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TagModelPaged>(
      {url: `/tags`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getTagControllerListTagsQueryKey = (params: TagControllerListTagsParams,) => {
    return [`/tags`, ...(params ? [params]: [])] as const;
    }

    
export const getTagControllerListTagsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof tagControllerListTags>>, TagControllerListTagsParams['page']>, TError = ErrorType<unknown>>(params: TagControllerListTagsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerListTags>>, TError, TData, Awaited<ReturnType<typeof tagControllerListTags>>, QueryKey, TagControllerListTagsParams['page']>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTagControllerListTagsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tagControllerListTags>>, QueryKey, TagControllerListTagsParams['page']> = ({ signal, pageParam }) => tagControllerListTags({...params, page: pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerListTags>>, TError, TData, Awaited<ReturnType<typeof tagControllerListTags>>, QueryKey, TagControllerListTagsParams['page']> & { queryKey: DataTag<QueryKey, TData> }
}

export type TagControllerListTagsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof tagControllerListTags>>>
export type TagControllerListTagsInfiniteQueryError = ErrorType<unknown>


export function useTagControllerListTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof tagControllerListTags>>, TagControllerListTagsParams['page']>, TError = ErrorType<unknown>>(
 params: TagControllerListTagsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerListTags>>, TError, TData, Awaited<ReturnType<typeof tagControllerListTags>>, QueryKey, TagControllerListTagsParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagControllerListTags>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTagControllerListTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof tagControllerListTags>>, TagControllerListTagsParams['page']>, TError = ErrorType<unknown>>(
 params: TagControllerListTagsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerListTags>>, TError, TData, Awaited<ReturnType<typeof tagControllerListTags>>, QueryKey, TagControllerListTagsParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagControllerListTags>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTagControllerListTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof tagControllerListTags>>, TagControllerListTagsParams['page']>, TError = ErrorType<unknown>>(
 params: TagControllerListTagsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerListTags>>, TError, TData, Awaited<ReturnType<typeof tagControllerListTags>>, QueryKey, TagControllerListTagsParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTagControllerListTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof tagControllerListTags>>, TagControllerListTagsParams['page']>, TError = ErrorType<unknown>>(
 params: TagControllerListTagsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerListTags>>, TError, TData, Awaited<ReturnType<typeof tagControllerListTags>>, QueryKey, TagControllerListTagsParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTagControllerListTagsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getTagControllerListTagsQueryOptions = <TData = Awaited<ReturnType<typeof tagControllerListTags>>, TError = ErrorType<unknown>>(params: TagControllerListTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerListTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTagControllerListTagsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tagControllerListTags>>> = ({ signal }) => tagControllerListTags(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tagControllerListTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TagControllerListTagsQueryResult = NonNullable<Awaited<ReturnType<typeof tagControllerListTags>>>
export type TagControllerListTagsQueryError = ErrorType<unknown>


export function useTagControllerListTags<TData = Awaited<ReturnType<typeof tagControllerListTags>>, TError = ErrorType<unknown>>(
 params: TagControllerListTagsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerListTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagControllerListTags>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTagControllerListTags<TData = Awaited<ReturnType<typeof tagControllerListTags>>, TError = ErrorType<unknown>>(
 params: TagControllerListTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerListTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagControllerListTags>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTagControllerListTags<TData = Awaited<ReturnType<typeof tagControllerListTags>>, TError = ErrorType<unknown>>(
 params: TagControllerListTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerListTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTagControllerListTags<TData = Awaited<ReturnType<typeof tagControllerListTags>>, TError = ErrorType<unknown>>(
 params: TagControllerListTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerListTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTagControllerListTagsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tagControllerUpdateTag = (
    id: string,
    updateTagDto: BodyType<UpdateTagDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/tags/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateTagDto
    },
      options);
    }
  


export const getTagControllerUpdateTagMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagControllerUpdateTag>>, TError,{id: string;data: BodyType<UpdateTagDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tagControllerUpdateTag>>, TError,{id: string;data: BodyType<UpdateTagDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagControllerUpdateTag>>, {id: string;data: BodyType<UpdateTagDto>}> = (props) => {
          const {id,data} = props ?? {};

          return  tagControllerUpdateTag(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagControllerUpdateTagMutationResult = NonNullable<Awaited<ReturnType<typeof tagControllerUpdateTag>>>
    export type TagControllerUpdateTagMutationBody = BodyType<UpdateTagDto>
    export type TagControllerUpdateTagMutationError = ErrorType<unknown>

    export const useTagControllerUpdateTag = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagControllerUpdateTag>>, TError,{id: string;data: BodyType<UpdateTagDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof tagControllerUpdateTag>>,
        TError,
        {id: string;data: BodyType<UpdateTagDto>},
        TContext
      > => {

      const mutationOptions = getTagControllerUpdateTagMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const tagControllerDeleteTag = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/tags/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getTagControllerDeleteTagMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagControllerDeleteTag>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tagControllerDeleteTag>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagControllerDeleteTag>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  tagControllerDeleteTag(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagControllerDeleteTagMutationResult = NonNullable<Awaited<ReturnType<typeof tagControllerDeleteTag>>>
    
    export type TagControllerDeleteTagMutationError = ErrorType<unknown>

    export const useTagControllerDeleteTag = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagControllerDeleteTag>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof tagControllerDeleteTag>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getTagControllerDeleteTagMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const tagControllerFilterTag = (
    params: TagControllerFilterTagParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/tags/filter`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getTagControllerFilterTagQueryKey = (params: TagControllerFilterTagParams,) => {
    return [`/tags/filter`, ...(params ? [params]: [])] as const;
    }

    
export const getTagControllerFilterTagInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof tagControllerFilterTag>>, TagControllerFilterTagParams['page']>, TError = ErrorType<unknown>>(params: TagControllerFilterTagParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerFilterTag>>, TError, TData, Awaited<ReturnType<typeof tagControllerFilterTag>>, QueryKey, TagControllerFilterTagParams['page']>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTagControllerFilterTagQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tagControllerFilterTag>>, QueryKey, TagControllerFilterTagParams['page']> = ({ signal, pageParam }) => tagControllerFilterTag({...params, page: pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerFilterTag>>, TError, TData, Awaited<ReturnType<typeof tagControllerFilterTag>>, QueryKey, TagControllerFilterTagParams['page']> & { queryKey: DataTag<QueryKey, TData> }
}

export type TagControllerFilterTagInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof tagControllerFilterTag>>>
export type TagControllerFilterTagInfiniteQueryError = ErrorType<unknown>


export function useTagControllerFilterTagInfinite<TData = InfiniteData<Awaited<ReturnType<typeof tagControllerFilterTag>>, TagControllerFilterTagParams['page']>, TError = ErrorType<unknown>>(
 params: TagControllerFilterTagParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerFilterTag>>, TError, TData, Awaited<ReturnType<typeof tagControllerFilterTag>>, QueryKey, TagControllerFilterTagParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagControllerFilterTag>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTagControllerFilterTagInfinite<TData = InfiniteData<Awaited<ReturnType<typeof tagControllerFilterTag>>, TagControllerFilterTagParams['page']>, TError = ErrorType<unknown>>(
 params: TagControllerFilterTagParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerFilterTag>>, TError, TData, Awaited<ReturnType<typeof tagControllerFilterTag>>, QueryKey, TagControllerFilterTagParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagControllerFilterTag>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTagControllerFilterTagInfinite<TData = InfiniteData<Awaited<ReturnType<typeof tagControllerFilterTag>>, TagControllerFilterTagParams['page']>, TError = ErrorType<unknown>>(
 params: TagControllerFilterTagParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerFilterTag>>, TError, TData, Awaited<ReturnType<typeof tagControllerFilterTag>>, QueryKey, TagControllerFilterTagParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTagControllerFilterTagInfinite<TData = InfiniteData<Awaited<ReturnType<typeof tagControllerFilterTag>>, TagControllerFilterTagParams['page']>, TError = ErrorType<unknown>>(
 params: TagControllerFilterTagParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerFilterTag>>, TError, TData, Awaited<ReturnType<typeof tagControllerFilterTag>>, QueryKey, TagControllerFilterTagParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTagControllerFilterTagInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getTagControllerFilterTagQueryOptions = <TData = Awaited<ReturnType<typeof tagControllerFilterTag>>, TError = ErrorType<unknown>>(params: TagControllerFilterTagParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerFilterTag>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTagControllerFilterTagQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tagControllerFilterTag>>> = ({ signal }) => tagControllerFilterTag(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tagControllerFilterTag>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TagControllerFilterTagQueryResult = NonNullable<Awaited<ReturnType<typeof tagControllerFilterTag>>>
export type TagControllerFilterTagQueryError = ErrorType<unknown>


export function useTagControllerFilterTag<TData = Awaited<ReturnType<typeof tagControllerFilterTag>>, TError = ErrorType<unknown>>(
 params: TagControllerFilterTagParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerFilterTag>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagControllerFilterTag>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTagControllerFilterTag<TData = Awaited<ReturnType<typeof tagControllerFilterTag>>, TError = ErrorType<unknown>>(
 params: TagControllerFilterTagParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerFilterTag>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagControllerFilterTag>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTagControllerFilterTag<TData = Awaited<ReturnType<typeof tagControllerFilterTag>>, TError = ErrorType<unknown>>(
 params: TagControllerFilterTagParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerFilterTag>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTagControllerFilterTag<TData = Awaited<ReturnType<typeof tagControllerFilterTag>>, TError = ErrorType<unknown>>(
 params: TagControllerFilterTagParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerFilterTag>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTagControllerFilterTagQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tagControllerFetchAllTags = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TagModel[]>(
      {url: `/tags/all`, method: 'GET', signal
    },
      options);
    }
  

export const getTagControllerFetchAllTagsQueryKey = () => {
    return [`/tags/all`] as const;
    }

    
export const getTagControllerFetchAllTagsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof tagControllerFetchAllTags>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTagControllerFetchAllTagsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tagControllerFetchAllTags>>> = ({ signal }) => tagControllerFetchAllTags(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TagControllerFetchAllTagsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof tagControllerFetchAllTags>>>
export type TagControllerFetchAllTagsInfiniteQueryError = ErrorType<unknown>


export function useTagControllerFetchAllTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof tagControllerFetchAllTags>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagControllerFetchAllTags>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTagControllerFetchAllTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof tagControllerFetchAllTags>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagControllerFetchAllTags>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTagControllerFetchAllTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof tagControllerFetchAllTags>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTagControllerFetchAllTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof tagControllerFetchAllTags>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTagControllerFetchAllTagsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getTagControllerFetchAllTagsQueryOptions = <TData = Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTagControllerFetchAllTagsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tagControllerFetchAllTags>>> = ({ signal }) => tagControllerFetchAllTags(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TagControllerFetchAllTagsQueryResult = NonNullable<Awaited<ReturnType<typeof tagControllerFetchAllTags>>>
export type TagControllerFetchAllTagsQueryError = ErrorType<unknown>


export function useTagControllerFetchAllTags<TData = Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagControllerFetchAllTags>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTagControllerFetchAllTags<TData = Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagControllerFetchAllTags>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTagControllerFetchAllTags<TData = Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTagControllerFetchAllTags<TData = Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagControllerFetchAllTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTagControllerFetchAllTagsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const searchTokenControllerCreateSearchToken = (
    createSearchTokenDto: BodyType<CreateSearchTokenDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/search-token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSearchTokenDto, signal
    },
      options);
    }
  


export const getSearchTokenControllerCreateSearchTokenMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchTokenControllerCreateSearchToken>>, TError,{data: BodyType<CreateSearchTokenDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchTokenControllerCreateSearchToken>>, TError,{data: BodyType<CreateSearchTokenDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchTokenControllerCreateSearchToken>>, {data: BodyType<CreateSearchTokenDto>}> = (props) => {
          const {data} = props ?? {};

          return  searchTokenControllerCreateSearchToken(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchTokenControllerCreateSearchTokenMutationResult = NonNullable<Awaited<ReturnType<typeof searchTokenControllerCreateSearchToken>>>
    export type SearchTokenControllerCreateSearchTokenMutationBody = BodyType<CreateSearchTokenDto>
    export type SearchTokenControllerCreateSearchTokenMutationError = ErrorType<unknown>

    export const useSearchTokenControllerCreateSearchToken = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchTokenControllerCreateSearchToken>>, TError,{data: BodyType<CreateSearchTokenDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof searchTokenControllerCreateSearchToken>>,
        TError,
        {data: BodyType<CreateSearchTokenDto>},
        TContext
      > => {

      const mutationOptions = getSearchTokenControllerCreateSearchTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const searchTokenControllerListSearchTokens = (
    params: SearchTokenControllerListSearchTokensParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SearchTokenHttp[]>(
      {url: `/search-token`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSearchTokenControllerListSearchTokensQueryKey = (params: SearchTokenControllerListSearchTokensParams,) => {
    return [`/search-token`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchTokenControllerListSearchTokensInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, SearchTokenControllerListSearchTokensParams['page']>, TError = ErrorType<unknown>>(params: SearchTokenControllerListSearchTokensParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError, TData, Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, QueryKey, SearchTokenControllerListSearchTokensParams['page']>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchTokenControllerListSearchTokensQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, QueryKey, SearchTokenControllerListSearchTokensParams['page']> = ({ signal, pageParam }) => searchTokenControllerListSearchTokens({...params, page: pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError, TData, Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, QueryKey, SearchTokenControllerListSearchTokensParams['page']> & { queryKey: DataTag<QueryKey, TData> }
}

export type SearchTokenControllerListSearchTokensInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>>
export type SearchTokenControllerListSearchTokensInfiniteQueryError = ErrorType<unknown>


export function useSearchTokenControllerListSearchTokensInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, SearchTokenControllerListSearchTokensParams['page']>, TError = ErrorType<unknown>>(
 params: SearchTokenControllerListSearchTokensParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError, TData, Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, QueryKey, SearchTokenControllerListSearchTokensParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchTokenControllerListSearchTokensInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, SearchTokenControllerListSearchTokensParams['page']>, TError = ErrorType<unknown>>(
 params: SearchTokenControllerListSearchTokensParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError, TData, Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, QueryKey, SearchTokenControllerListSearchTokensParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchTokenControllerListSearchTokensInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, SearchTokenControllerListSearchTokensParams['page']>, TError = ErrorType<unknown>>(
 params: SearchTokenControllerListSearchTokensParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError, TData, Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, QueryKey, SearchTokenControllerListSearchTokensParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useSearchTokenControllerListSearchTokensInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, SearchTokenControllerListSearchTokensParams['page']>, TError = ErrorType<unknown>>(
 params: SearchTokenControllerListSearchTokensParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError, TData, Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, QueryKey, SearchTokenControllerListSearchTokensParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSearchTokenControllerListSearchTokensInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSearchTokenControllerListSearchTokensQueryOptions = <TData = Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError = ErrorType<unknown>>(params: SearchTokenControllerListSearchTokensParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchTokenControllerListSearchTokensQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>> = ({ signal }) => searchTokenControllerListSearchTokens(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SearchTokenControllerListSearchTokensQueryResult = NonNullable<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>>
export type SearchTokenControllerListSearchTokensQueryError = ErrorType<unknown>


export function useSearchTokenControllerListSearchTokens<TData = Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError = ErrorType<unknown>>(
 params: SearchTokenControllerListSearchTokensParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchTokenControllerListSearchTokens<TData = Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError = ErrorType<unknown>>(
 params: SearchTokenControllerListSearchTokensParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchTokenControllerListSearchTokens<TData = Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError = ErrorType<unknown>>(
 params: SearchTokenControllerListSearchTokensParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useSearchTokenControllerListSearchTokens<TData = Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError = ErrorType<unknown>>(
 params: SearchTokenControllerListSearchTokensParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchTokenControllerListSearchTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSearchTokenControllerListSearchTokensQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const searchTokenControllerCreateManySearchTokens = (
    createManySearchTokensDto: BodyType<CreateManySearchTokensDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/search-token/batch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createManySearchTokensDto, signal
    },
      options);
    }
  


export const getSearchTokenControllerCreateManySearchTokensMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchTokenControllerCreateManySearchTokens>>, TError,{data: BodyType<CreateManySearchTokensDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchTokenControllerCreateManySearchTokens>>, TError,{data: BodyType<CreateManySearchTokensDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchTokenControllerCreateManySearchTokens>>, {data: BodyType<CreateManySearchTokensDto>}> = (props) => {
          const {data} = props ?? {};

          return  searchTokenControllerCreateManySearchTokens(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchTokenControllerCreateManySearchTokensMutationResult = NonNullable<Awaited<ReturnType<typeof searchTokenControllerCreateManySearchTokens>>>
    export type SearchTokenControllerCreateManySearchTokensMutationBody = BodyType<CreateManySearchTokensDto>
    export type SearchTokenControllerCreateManySearchTokensMutationError = ErrorType<unknown>

    export const useSearchTokenControllerCreateManySearchTokens = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchTokenControllerCreateManySearchTokens>>, TError,{data: BodyType<CreateManySearchTokensDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof searchTokenControllerCreateManySearchTokens>>,
        TError,
        {data: BodyType<CreateManySearchTokensDto>},
        TContext
      > => {

      const mutationOptions = getSearchTokenControllerCreateManySearchTokensMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const searchTokenControllerDeleteSearchToken = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/search-token/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getSearchTokenControllerDeleteSearchTokenMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchTokenControllerDeleteSearchToken>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchTokenControllerDeleteSearchToken>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchTokenControllerDeleteSearchToken>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  searchTokenControllerDeleteSearchToken(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchTokenControllerDeleteSearchTokenMutationResult = NonNullable<Awaited<ReturnType<typeof searchTokenControllerDeleteSearchToken>>>
    
    export type SearchTokenControllerDeleteSearchTokenMutationError = ErrorType<unknown>

    export const useSearchTokenControllerDeleteSearchToken = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchTokenControllerDeleteSearchToken>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof searchTokenControllerDeleteSearchToken>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getSearchTokenControllerDeleteSearchTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const calendarControllerFetchUserCalendar = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CalendarModel>(
      {url: `/calendar`, method: 'GET', signal
    },
      options);
    }
  

export const getCalendarControllerFetchUserCalendarQueryKey = () => {
    return [`/calendar`] as const;
    }

    
export const getCalendarControllerFetchUserCalendarInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>>, TError = ErrorType<CalendarModel>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCalendarControllerFetchUserCalendarQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>> = ({ signal }) => calendarControllerFetchUserCalendar(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CalendarControllerFetchUserCalendarInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>>
export type CalendarControllerFetchUserCalendarInfiniteQueryError = ErrorType<CalendarModel>


export function useCalendarControllerFetchUserCalendarInfinite<TData = InfiniteData<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>>, TError = ErrorType<CalendarModel>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCalendarControllerFetchUserCalendarInfinite<TData = InfiniteData<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>>, TError = ErrorType<CalendarModel>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCalendarControllerFetchUserCalendarInfinite<TData = InfiniteData<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>>, TError = ErrorType<CalendarModel>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useCalendarControllerFetchUserCalendarInfinite<TData = InfiniteData<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>>, TError = ErrorType<CalendarModel>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCalendarControllerFetchUserCalendarInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCalendarControllerFetchUserCalendarQueryOptions = <TData = Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError = ErrorType<CalendarModel>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCalendarControllerFetchUserCalendarQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>> = ({ signal }) => calendarControllerFetchUserCalendar(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CalendarControllerFetchUserCalendarQueryResult = NonNullable<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>>
export type CalendarControllerFetchUserCalendarQueryError = ErrorType<CalendarModel>


export function useCalendarControllerFetchUserCalendar<TData = Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError = ErrorType<CalendarModel>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCalendarControllerFetchUserCalendar<TData = Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError = ErrorType<CalendarModel>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCalendarControllerFetchUserCalendar<TData = Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError = ErrorType<CalendarModel>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useCalendarControllerFetchUserCalendar<TData = Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError = ErrorType<CalendarModel>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof calendarControllerFetchUserCalendar>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCalendarControllerFetchUserCalendarQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const calendarControllerCreate = (
    createCalendarDto: BodyType<CreateCalendarDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/calendar`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCalendarDto, signal
    },
      options);
    }
  


export const getCalendarControllerCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calendarControllerCreate>>, TError,{data: BodyType<CreateCalendarDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof calendarControllerCreate>>, TError,{data: BodyType<CreateCalendarDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calendarControllerCreate>>, {data: BodyType<CreateCalendarDto>}> = (props) => {
          const {data} = props ?? {};

          return  calendarControllerCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalendarControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof calendarControllerCreate>>>
    export type CalendarControllerCreateMutationBody = BodyType<CreateCalendarDto>
    export type CalendarControllerCreateMutationError = ErrorType<unknown>

    export const useCalendarControllerCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calendarControllerCreate>>, TError,{data: BodyType<CreateCalendarDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof calendarControllerCreate>>,
        TError,
        {data: BodyType<CreateCalendarDto>},
        TContext
      > => {

      const mutationOptions = getCalendarControllerCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const calendarControllerAddRowInCalendar = (
    addRowInCalendarDto: BodyType<AddRowInCalendarDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/calendar/row`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addRowInCalendarDto, signal
    },
      options);
    }
  


export const getCalendarControllerAddRowInCalendarMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calendarControllerAddRowInCalendar>>, TError,{data: BodyType<AddRowInCalendarDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof calendarControllerAddRowInCalendar>>, TError,{data: BodyType<AddRowInCalendarDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calendarControllerAddRowInCalendar>>, {data: BodyType<AddRowInCalendarDto>}> = (props) => {
          const {data} = props ?? {};

          return  calendarControllerAddRowInCalendar(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalendarControllerAddRowInCalendarMutationResult = NonNullable<Awaited<ReturnType<typeof calendarControllerAddRowInCalendar>>>
    export type CalendarControllerAddRowInCalendarMutationBody = BodyType<AddRowInCalendarDto>
    export type CalendarControllerAddRowInCalendarMutationError = ErrorType<unknown>

    export const useCalendarControllerAddRowInCalendar = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calendarControllerAddRowInCalendar>>, TError,{data: BodyType<AddRowInCalendarDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof calendarControllerAddRowInCalendar>>,
        TError,
        {data: BodyType<AddRowInCalendarDto>},
        TContext
      > => {

      const mutationOptions = getCalendarControllerAddRowInCalendarMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const calendarControllerRemoveRowFromCalendar = (
    rowId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/calendar/row/${rowId}`, method: 'DELETE'
    },
      options);
    }
  


export const getCalendarControllerRemoveRowFromCalendarMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calendarControllerRemoveRowFromCalendar>>, TError,{rowId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof calendarControllerRemoveRowFromCalendar>>, TError,{rowId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calendarControllerRemoveRowFromCalendar>>, {rowId: string}> = (props) => {
          const {rowId} = props ?? {};

          return  calendarControllerRemoveRowFromCalendar(rowId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalendarControllerRemoveRowFromCalendarMutationResult = NonNullable<Awaited<ReturnType<typeof calendarControllerRemoveRowFromCalendar>>>
    
    export type CalendarControllerRemoveRowFromCalendarMutationError = ErrorType<unknown>

    export const useCalendarControllerRemoveRowFromCalendar = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calendarControllerRemoveRowFromCalendar>>, TError,{rowId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof calendarControllerRemoveRowFromCalendar>>,
        TError,
        {rowId: string},
        TContext
      > => {

      const mutationOptions = getCalendarControllerRemoveRowFromCalendarMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const sharedWorkControllerCreateSharedWork = (
    createSharedWorkDto: BodyType<CreateSharedWorkDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateSharedWorkResponseModel>(
      {url: `/shared-work`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSharedWorkDto, signal
    },
      options);
    }
  


export const getSharedWorkControllerCreateSharedWorkMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sharedWorkControllerCreateSharedWork>>, TError,{data: BodyType<CreateSharedWorkDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sharedWorkControllerCreateSharedWork>>, TError,{data: BodyType<CreateSharedWorkDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sharedWorkControllerCreateSharedWork>>, {data: BodyType<CreateSharedWorkDto>}> = (props) => {
          const {data} = props ?? {};

          return  sharedWorkControllerCreateSharedWork(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SharedWorkControllerCreateSharedWorkMutationResult = NonNullable<Awaited<ReturnType<typeof sharedWorkControllerCreateSharedWork>>>
    export type SharedWorkControllerCreateSharedWorkMutationBody = BodyType<CreateSharedWorkDto>
    export type SharedWorkControllerCreateSharedWorkMutationError = ErrorType<unknown>

    export const useSharedWorkControllerCreateSharedWork = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sharedWorkControllerCreateSharedWork>>, TError,{data: BodyType<CreateSharedWorkDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof sharedWorkControllerCreateSharedWork>>,
        TError,
        {data: BodyType<CreateSharedWorkDto>},
        TContext
      > => {

      const mutationOptions = getSharedWorkControllerCreateSharedWorkMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const sharedWorkControllerFetchSharedWork = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FetchSharedWorkQueryResponse>(
      {url: `/shared-work/share/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getSharedWorkControllerFetchSharedWorkQueryKey = (id: string,) => {
    return [`/shared-work/share/${id}`] as const;
    }

    
export const getSharedWorkControllerFetchSharedWorkInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSharedWorkControllerFetchSharedWorkQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>> = ({ signal }) => sharedWorkControllerFetchSharedWork(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SharedWorkControllerFetchSharedWorkInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>>
export type SharedWorkControllerFetchSharedWorkInfiniteQueryError = ErrorType<unknown>


export function useSharedWorkControllerFetchSharedWorkInfinite<TData = InfiniteData<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSharedWorkControllerFetchSharedWorkInfinite<TData = InfiniteData<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSharedWorkControllerFetchSharedWorkInfinite<TData = InfiniteData<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useSharedWorkControllerFetchSharedWorkInfinite<TData = InfiniteData<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSharedWorkControllerFetchSharedWorkInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSharedWorkControllerFetchSharedWorkQueryOptions = <TData = Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSharedWorkControllerFetchSharedWorkQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>> = ({ signal }) => sharedWorkControllerFetchSharedWork(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SharedWorkControllerFetchSharedWorkQueryResult = NonNullable<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>>
export type SharedWorkControllerFetchSharedWorkQueryError = ErrorType<unknown>


export function useSharedWorkControllerFetchSharedWork<TData = Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSharedWorkControllerFetchSharedWork<TData = Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSharedWorkControllerFetchSharedWork<TData = Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useSharedWorkControllerFetchSharedWork<TData = Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sharedWorkControllerFetchSharedWork>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSharedWorkControllerFetchSharedWorkQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const customListControllerCreateCustomList = (
    createCustomListDto: BodyType<CreateCustomListDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateCustomListResponseModel>(
      {url: `/custom-list`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCustomListDto, signal
    },
      options);
    }
  


export const getCustomListControllerCreateCustomListMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customListControllerCreateCustomList>>, TError,{data: BodyType<CreateCustomListDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof customListControllerCreateCustomList>>, TError,{data: BodyType<CreateCustomListDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customListControllerCreateCustomList>>, {data: BodyType<CreateCustomListDto>}> = (props) => {
          const {data} = props ?? {};

          return  customListControllerCreateCustomList(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CustomListControllerCreateCustomListMutationResult = NonNullable<Awaited<ReturnType<typeof customListControllerCreateCustomList>>>
    export type CustomListControllerCreateCustomListMutationBody = BodyType<CreateCustomListDto>
    export type CustomListControllerCreateCustomListMutationError = ErrorType<unknown>

    export const useCustomListControllerCreateCustomList = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customListControllerCreateCustomList>>, TError,{data: BodyType<CreateCustomListDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof customListControllerCreateCustomList>>,
        TError,
        {data: BodyType<CreateCustomListDto>},
        TContext
      > => {

      const mutationOptions = getCustomListControllerCreateCustomListMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const customListControllerFetchCustomLists = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CustomListModel[]>(
      {url: `/custom-list`, method: 'GET', signal
    },
      options);
    }
  

export const getCustomListControllerFetchCustomListsQueryKey = () => {
    return [`/custom-list`] as const;
    }

    
export const getCustomListControllerFetchCustomListsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCustomListControllerFetchCustomListsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>> = ({ signal }) => customListControllerFetchCustomLists(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CustomListControllerFetchCustomListsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>>
export type CustomListControllerFetchCustomListsInfiniteQueryError = ErrorType<unknown>


export function useCustomListControllerFetchCustomListsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customListControllerFetchCustomLists>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCustomListControllerFetchCustomListsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customListControllerFetchCustomLists>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCustomListControllerFetchCustomListsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useCustomListControllerFetchCustomListsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCustomListControllerFetchCustomListsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCustomListControllerFetchCustomListsQueryOptions = <TData = Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCustomListControllerFetchCustomListsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>> = ({ signal }) => customListControllerFetchCustomLists(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CustomListControllerFetchCustomListsQueryResult = NonNullable<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>>
export type CustomListControllerFetchCustomListsQueryError = ErrorType<unknown>


export function useCustomListControllerFetchCustomLists<TData = Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customListControllerFetchCustomLists>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCustomListControllerFetchCustomLists<TData = Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customListControllerFetchCustomLists>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCustomListControllerFetchCustomLists<TData = Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useCustomListControllerFetchCustomLists<TData = Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomLists>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCustomListControllerFetchCustomListsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const customListControllerUpdateCustomList = (
    id: string,
    updateCustomListDto: BodyType<UpdateCustomListDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/custom-list/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateCustomListDto
    },
      options);
    }
  


export const getCustomListControllerUpdateCustomListMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customListControllerUpdateCustomList>>, TError,{id: string;data: BodyType<UpdateCustomListDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof customListControllerUpdateCustomList>>, TError,{id: string;data: BodyType<UpdateCustomListDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customListControllerUpdateCustomList>>, {id: string;data: BodyType<UpdateCustomListDto>}> = (props) => {
          const {id,data} = props ?? {};

          return  customListControllerUpdateCustomList(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CustomListControllerUpdateCustomListMutationResult = NonNullable<Awaited<ReturnType<typeof customListControllerUpdateCustomList>>>
    export type CustomListControllerUpdateCustomListMutationBody = BodyType<UpdateCustomListDto>
    export type CustomListControllerUpdateCustomListMutationError = ErrorType<unknown>

    export const useCustomListControllerUpdateCustomList = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customListControllerUpdateCustomList>>, TError,{id: string;data: BodyType<UpdateCustomListDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof customListControllerUpdateCustomList>>,
        TError,
        {id: string;data: BodyType<UpdateCustomListDto>},
        TContext
      > => {

      const mutationOptions = getCustomListControllerUpdateCustomListMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const customListControllerDeleteCustomList = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/custom-list/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getCustomListControllerDeleteCustomListMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customListControllerDeleteCustomList>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof customListControllerDeleteCustomList>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customListControllerDeleteCustomList>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  customListControllerDeleteCustomList(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CustomListControllerDeleteCustomListMutationResult = NonNullable<Awaited<ReturnType<typeof customListControllerDeleteCustomList>>>
    
    export type CustomListControllerDeleteCustomListMutationError = ErrorType<unknown>

    export const useCustomListControllerDeleteCustomList = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customListControllerDeleteCustomList>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof customListControllerDeleteCustomList>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getCustomListControllerDeleteCustomListMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const customListControllerFetchCustomListWorks = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CustomListWithWorksModel>(
      {url: `/custom-list/${id}/works`, method: 'GET', signal
    },
      options);
    }
  

export const getCustomListControllerFetchCustomListWorksQueryKey = (id: string,) => {
    return [`/custom-list/${id}/works`] as const;
    }

    
export const getCustomListControllerFetchCustomListWorksInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCustomListControllerFetchCustomListWorksQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>> = ({ signal }) => customListControllerFetchCustomListWorks(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CustomListControllerFetchCustomListWorksInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>>
export type CustomListControllerFetchCustomListWorksInfiniteQueryError = ErrorType<unknown>


export function useCustomListControllerFetchCustomListWorksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCustomListControllerFetchCustomListWorksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCustomListControllerFetchCustomListWorksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useCustomListControllerFetchCustomListWorksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCustomListControllerFetchCustomListWorksInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCustomListControllerFetchCustomListWorksQueryOptions = <TData = Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCustomListControllerFetchCustomListWorksQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>> = ({ signal }) => customListControllerFetchCustomListWorks(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CustomListControllerFetchCustomListWorksQueryResult = NonNullable<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>>
export type CustomListControllerFetchCustomListWorksQueryError = ErrorType<unknown>


export function useCustomListControllerFetchCustomListWorks<TData = Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCustomListControllerFetchCustomListWorks<TData = Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCustomListControllerFetchCustomListWorks<TData = Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useCustomListControllerFetchCustomListWorks<TData = Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListWorks>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCustomListControllerFetchCustomListWorksQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const customListControllerAddWorkToCustomList = (
    id: string,
    addWorkInCustomListDto: BodyType<AddWorkInCustomListDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/custom-list/${id}/works`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addWorkInCustomListDto, signal
    },
      options);
    }
  


export const getCustomListControllerAddWorkToCustomListMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customListControllerAddWorkToCustomList>>, TError,{id: string;data: BodyType<AddWorkInCustomListDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof customListControllerAddWorkToCustomList>>, TError,{id: string;data: BodyType<AddWorkInCustomListDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customListControllerAddWorkToCustomList>>, {id: string;data: BodyType<AddWorkInCustomListDto>}> = (props) => {
          const {id,data} = props ?? {};

          return  customListControllerAddWorkToCustomList(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CustomListControllerAddWorkToCustomListMutationResult = NonNullable<Awaited<ReturnType<typeof customListControllerAddWorkToCustomList>>>
    export type CustomListControllerAddWorkToCustomListMutationBody = BodyType<AddWorkInCustomListDto>
    export type CustomListControllerAddWorkToCustomListMutationError = ErrorType<unknown>

    export const useCustomListControllerAddWorkToCustomList = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customListControllerAddWorkToCustomList>>, TError,{id: string;data: BodyType<AddWorkInCustomListDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof customListControllerAddWorkToCustomList>>,
        TError,
        {id: string;data: BodyType<AddWorkInCustomListDto>},
        TContext
      > => {

      const mutationOptions = getCustomListControllerAddWorkToCustomListMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const customListControllerDeleteWorkFromCustomList = (
    id: string,
    workId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/custom-list/${id}/works/${workId}`, method: 'DELETE'
    },
      options);
    }
  


export const getCustomListControllerDeleteWorkFromCustomListMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customListControllerDeleteWorkFromCustomList>>, TError,{id: string;workId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof customListControllerDeleteWorkFromCustomList>>, TError,{id: string;workId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customListControllerDeleteWorkFromCustomList>>, {id: string;workId: string}> = (props) => {
          const {id,workId} = props ?? {};

          return  customListControllerDeleteWorkFromCustomList(id,workId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CustomListControllerDeleteWorkFromCustomListMutationResult = NonNullable<Awaited<ReturnType<typeof customListControllerDeleteWorkFromCustomList>>>
    
    export type CustomListControllerDeleteWorkFromCustomListMutationError = ErrorType<unknown>

    export const useCustomListControllerDeleteWorkFromCustomList = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customListControllerDeleteWorkFromCustomList>>, TError,{id: string;workId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof customListControllerDeleteWorkFromCustomList>>,
        TError,
        {id: string;workId: string},
        TContext
      > => {

      const mutationOptions = getCustomListControllerDeleteWorkFromCustomListMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const customListControllerShareCustomList = (
    toggleShareCollectionDto: BodyType<ToggleShareCollectionDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/custom-list/share`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: toggleShareCollectionDto
    },
      options);
    }
  


export const getCustomListControllerShareCustomListMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customListControllerShareCustomList>>, TError,{data: BodyType<ToggleShareCollectionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof customListControllerShareCustomList>>, TError,{data: BodyType<ToggleShareCollectionDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customListControllerShareCustomList>>, {data: BodyType<ToggleShareCollectionDto>}> = (props) => {
          const {data} = props ?? {};

          return  customListControllerShareCustomList(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CustomListControllerShareCustomListMutationResult = NonNullable<Awaited<ReturnType<typeof customListControllerShareCustomList>>>
    export type CustomListControllerShareCustomListMutationBody = BodyType<ToggleShareCollectionDto>
    export type CustomListControllerShareCustomListMutationError = ErrorType<unknown>

    export const useCustomListControllerShareCustomList = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customListControllerShareCustomList>>, TError,{data: BodyType<ToggleShareCollectionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof customListControllerShareCustomList>>,
        TError,
        {data: BodyType<ToggleShareCollectionDto>},
        TContext
      > => {

      const mutationOptions = getCustomListControllerShareCustomListMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const customListControllerFetchCustomListByPublicId = (
    publicId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SharedCustomListModel>(
      {url: `/custom-list/share/${publicId}`, method: 'GET', signal
    },
      options);
    }
  

export const getCustomListControllerFetchCustomListByPublicIdQueryKey = (publicId: string,) => {
    return [`/custom-list/share/${publicId}`] as const;
    }

    
export const getCustomListControllerFetchCustomListByPublicIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>>, TError = ErrorType<unknown>>(publicId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCustomListControllerFetchCustomListByPublicIdQueryKey(publicId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>> = ({ signal }) => customListControllerFetchCustomListByPublicId(publicId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publicId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CustomListControllerFetchCustomListByPublicIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>>
export type CustomListControllerFetchCustomListByPublicIdInfiniteQueryError = ErrorType<unknown>


export function useCustomListControllerFetchCustomListByPublicIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>>, TError = ErrorType<unknown>>(
 publicId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCustomListControllerFetchCustomListByPublicIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>>, TError = ErrorType<unknown>>(
 publicId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCustomListControllerFetchCustomListByPublicIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>>, TError = ErrorType<unknown>>(
 publicId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useCustomListControllerFetchCustomListByPublicIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>>, TError = ErrorType<unknown>>(
 publicId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCustomListControllerFetchCustomListByPublicIdInfiniteQueryOptions(publicId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCustomListControllerFetchCustomListByPublicIdQueryOptions = <TData = Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError = ErrorType<unknown>>(publicId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCustomListControllerFetchCustomListByPublicIdQueryKey(publicId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>> = ({ signal }) => customListControllerFetchCustomListByPublicId(publicId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publicId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CustomListControllerFetchCustomListByPublicIdQueryResult = NonNullable<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>>
export type CustomListControllerFetchCustomListByPublicIdQueryError = ErrorType<unknown>


export function useCustomListControllerFetchCustomListByPublicId<TData = Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError = ErrorType<unknown>>(
 publicId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCustomListControllerFetchCustomListByPublicId<TData = Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError = ErrorType<unknown>>(
 publicId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCustomListControllerFetchCustomListByPublicId<TData = Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError = ErrorType<unknown>>(
 publicId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useCustomListControllerFetchCustomListByPublicId<TData = Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError = ErrorType<unknown>>(
 publicId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof customListControllerFetchCustomListByPublicId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCustomListControllerFetchCustomListByPublicIdQueryOptions(publicId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const scrappingReportControllerScrappingFallback = (
    scrappingReportDto: BodyType<ScrappingReportDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/scrapping-report`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: scrappingReportDto, signal
    },
      options);
    }
  


export const getScrappingReportControllerScrappingFallbackMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrappingReportControllerScrappingFallback>>, TError,{data: BodyType<ScrappingReportDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof scrappingReportControllerScrappingFallback>>, TError,{data: BodyType<ScrappingReportDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scrappingReportControllerScrappingFallback>>, {data: BodyType<ScrappingReportDto>}> = (props) => {
          const {data} = props ?? {};

          return  scrappingReportControllerScrappingFallback(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScrappingReportControllerScrappingFallbackMutationResult = NonNullable<Awaited<ReturnType<typeof scrappingReportControllerScrappingFallback>>>
    export type ScrappingReportControllerScrappingFallbackMutationBody = BodyType<ScrappingReportDto>
    export type ScrappingReportControllerScrappingFallbackMutationError = ErrorType<unknown>

    export const useScrappingReportControllerScrappingFallback = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrappingReportControllerScrappingFallback>>, TError,{data: BodyType<ScrappingReportDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof scrappingReportControllerScrappingFallback>>,
        TError,
        {data: BodyType<ScrappingReportDto>},
        TContext
      > => {

      const mutationOptions = getScrappingReportControllerScrappingFallbackMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const scrappingReportControllerFetchForWorksScrapingReportPaginated = (
    params: ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ScrappingReportWorkModel>(
      {url: `/scrapping-report`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getScrappingReportControllerFetchForWorksScrapingReportPaginatedQueryKey = (params: ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams,) => {
    return [`/scrapping-report`, ...(params ? [params]: [])] as const;
    }

    
export const getScrappingReportControllerFetchForWorksScrapingReportPaginatedInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams['page']>, TError = ErrorType<unknown>>(params: ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError, TData, Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, QueryKey, ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams['page']>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getScrappingReportControllerFetchForWorksScrapingReportPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, QueryKey, ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams['page']> = ({ signal, pageParam }) => scrappingReportControllerFetchForWorksScrapingReportPaginated({...params, page: pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError, TData, Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, QueryKey, ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams['page']> & { queryKey: DataTag<QueryKey, TData> }
}

export type ScrappingReportControllerFetchForWorksScrapingReportPaginatedInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>>
export type ScrappingReportControllerFetchForWorksScrapingReportPaginatedInfiniteQueryError = ErrorType<unknown>


export function useScrappingReportControllerFetchForWorksScrapingReportPaginatedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams['page']>, TError = ErrorType<unknown>>(
 params: ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError, TData, Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, QueryKey, ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useScrappingReportControllerFetchForWorksScrapingReportPaginatedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams['page']>, TError = ErrorType<unknown>>(
 params: ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError, TData, Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, QueryKey, ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useScrappingReportControllerFetchForWorksScrapingReportPaginatedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams['page']>, TError = ErrorType<unknown>>(
 params: ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError, TData, Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, QueryKey, ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useScrappingReportControllerFetchForWorksScrapingReportPaginatedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams['page']>, TError = ErrorType<unknown>>(
 params: ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError, TData, Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, QueryKey, ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getScrappingReportControllerFetchForWorksScrapingReportPaginatedInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getScrappingReportControllerFetchForWorksScrapingReportPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError = ErrorType<unknown>>(params: ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getScrappingReportControllerFetchForWorksScrapingReportPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>> = ({ signal }) => scrappingReportControllerFetchForWorksScrapingReportPaginated(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ScrappingReportControllerFetchForWorksScrapingReportPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>>
export type ScrappingReportControllerFetchForWorksScrapingReportPaginatedQueryError = ErrorType<unknown>


export function useScrappingReportControllerFetchForWorksScrapingReportPaginated<TData = Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError = ErrorType<unknown>>(
 params: ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useScrappingReportControllerFetchForWorksScrapingReportPaginated<TData = Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError = ErrorType<unknown>>(
 params: ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useScrappingReportControllerFetchForWorksScrapingReportPaginated<TData = Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError = ErrorType<unknown>>(
 params: ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useScrappingReportControllerFetchForWorksScrapingReportPaginated<TData = Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError = ErrorType<unknown>>(
 params: ScrappingReportControllerFetchForWorksScrapingReportPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrappingReportControllerFetchForWorksScrapingReportPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getScrappingReportControllerFetchForWorksScrapingReportPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const scrappingReportControllerSyncWork = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/scrapping-report/sync`, method: 'POST', signal
    },
      options);
    }
  


export const getScrappingReportControllerSyncWorkMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrappingReportControllerSyncWork>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof scrappingReportControllerSyncWork>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scrappingReportControllerSyncWork>>, void> = () => {
          

          return  scrappingReportControllerSyncWork(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScrappingReportControllerSyncWorkMutationResult = NonNullable<Awaited<ReturnType<typeof scrappingReportControllerSyncWork>>>
    
    export type ScrappingReportControllerSyncWorkMutationError = ErrorType<unknown>

    export const useScrappingReportControllerSyncWork = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrappingReportControllerSyncWork>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof scrappingReportControllerSyncWork>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getScrappingReportControllerSyncWorkMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const scrappingReportControllerRefreshChapters = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/scrapping-report/sync/all`, method: 'POST', signal
    },
      options);
    }
  


export const getScrappingReportControllerRefreshChaptersMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrappingReportControllerRefreshChapters>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof scrappingReportControllerRefreshChapters>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scrappingReportControllerRefreshChapters>>, void> = () => {
          

          return  scrappingReportControllerRefreshChapters(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScrappingReportControllerRefreshChaptersMutationResult = NonNullable<Awaited<ReturnType<typeof scrappingReportControllerRefreshChapters>>>
    
    export type ScrappingReportControllerRefreshChaptersMutationError = ErrorType<unknown>

    export const useScrappingReportControllerRefreshChapters = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrappingReportControllerRefreshChapters>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof scrappingReportControllerRefreshChapters>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getScrappingReportControllerRefreshChaptersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const scrappingReportControllerSyncToNotion = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/scrapping-report/sync/notion`, method: 'POST', signal
    },
      options);
    }
  


export const getScrappingReportControllerSyncToNotionMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrappingReportControllerSyncToNotion>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof scrappingReportControllerSyncToNotion>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scrappingReportControllerSyncToNotion>>, void> = () => {
          

          return  scrappingReportControllerSyncToNotion(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScrappingReportControllerSyncToNotionMutationResult = NonNullable<Awaited<ReturnType<typeof scrappingReportControllerSyncToNotion>>>
    
    export type ScrappingReportControllerSyncToNotionMutationError = ErrorType<unknown>

    export const useScrappingReportControllerSyncToNotion = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrappingReportControllerSyncToNotion>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof scrappingReportControllerSyncToNotion>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getScrappingReportControllerSyncToNotionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const integrationControllerListSearchTokens = (
    params: IntegrationControllerListSearchTokensParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SearchTokenHttp[]>(
      {url: `/integration/search-token`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getIntegrationControllerListSearchTokensQueryKey = (params: IntegrationControllerListSearchTokensParams,) => {
    return [`/integration/search-token`, ...(params ? [params]: [])] as const;
    }

    
export const getIntegrationControllerListSearchTokensInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, IntegrationControllerListSearchTokensParams['page']>, TError = ErrorType<unknown>>(params: IntegrationControllerListSearchTokensParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError, TData, Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, QueryKey, IntegrationControllerListSearchTokensParams['page']>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIntegrationControllerListSearchTokensQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, QueryKey, IntegrationControllerListSearchTokensParams['page']> = ({ signal, pageParam }) => integrationControllerListSearchTokens({...params, page: pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError, TData, Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, QueryKey, IntegrationControllerListSearchTokensParams['page']> & { queryKey: DataTag<QueryKey, TData> }
}

export type IntegrationControllerListSearchTokensInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>>
export type IntegrationControllerListSearchTokensInfiniteQueryError = ErrorType<unknown>


export function useIntegrationControllerListSearchTokensInfinite<TData = InfiniteData<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, IntegrationControllerListSearchTokensParams['page']>, TError = ErrorType<unknown>>(
 params: IntegrationControllerListSearchTokensParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError, TData, Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, QueryKey, IntegrationControllerListSearchTokensParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof integrationControllerListSearchTokens>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useIntegrationControllerListSearchTokensInfinite<TData = InfiniteData<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, IntegrationControllerListSearchTokensParams['page']>, TError = ErrorType<unknown>>(
 params: IntegrationControllerListSearchTokensParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError, TData, Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, QueryKey, IntegrationControllerListSearchTokensParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof integrationControllerListSearchTokens>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useIntegrationControllerListSearchTokensInfinite<TData = InfiniteData<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, IntegrationControllerListSearchTokensParams['page']>, TError = ErrorType<unknown>>(
 params: IntegrationControllerListSearchTokensParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError, TData, Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, QueryKey, IntegrationControllerListSearchTokensParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useIntegrationControllerListSearchTokensInfinite<TData = InfiniteData<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, IntegrationControllerListSearchTokensParams['page']>, TError = ErrorType<unknown>>(
 params: IntegrationControllerListSearchTokensParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError, TData, Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, QueryKey, IntegrationControllerListSearchTokensParams['page']>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getIntegrationControllerListSearchTokensInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getIntegrationControllerListSearchTokensQueryOptions = <TData = Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError = ErrorType<unknown>>(params: IntegrationControllerListSearchTokensParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIntegrationControllerListSearchTokensQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>> = ({ signal }) => integrationControllerListSearchTokens(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type IntegrationControllerListSearchTokensQueryResult = NonNullable<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>>
export type IntegrationControllerListSearchTokensQueryError = ErrorType<unknown>


export function useIntegrationControllerListSearchTokens<TData = Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError = ErrorType<unknown>>(
 params: IntegrationControllerListSearchTokensParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof integrationControllerListSearchTokens>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useIntegrationControllerListSearchTokens<TData = Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError = ErrorType<unknown>>(
 params: IntegrationControllerListSearchTokensParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof integrationControllerListSearchTokens>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useIntegrationControllerListSearchTokens<TData = Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError = ErrorType<unknown>>(
 params: IntegrationControllerListSearchTokensParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useIntegrationControllerListSearchTokens<TData = Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError = ErrorType<unknown>>(
 params: IntegrationControllerListSearchTokensParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof integrationControllerListSearchTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getIntegrationControllerListSearchTokensQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const loggerControllerHealthCheck = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LoggerControllerHealthCheck200>(
      {url: `/health`, method: 'GET', signal
    },
      options);
    }
  

export const getLoggerControllerHealthCheckQueryKey = () => {
    return [`/health`] as const;
    }

    
export const getLoggerControllerHealthCheckInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof loggerControllerHealthCheck>>>, TError = ErrorType<LoggerControllerHealthCheck503>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLoggerControllerHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof loggerControllerHealthCheck>>> = ({ signal }) => loggerControllerHealthCheck(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type LoggerControllerHealthCheckInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof loggerControllerHealthCheck>>>
export type LoggerControllerHealthCheckInfiniteQueryError = ErrorType<LoggerControllerHealthCheck503>


export function useLoggerControllerHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof loggerControllerHealthCheck>>>, TError = ErrorType<LoggerControllerHealthCheck503>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof loggerControllerHealthCheck>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useLoggerControllerHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof loggerControllerHealthCheck>>>, TError = ErrorType<LoggerControllerHealthCheck503>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof loggerControllerHealthCheck>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useLoggerControllerHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof loggerControllerHealthCheck>>>, TError = ErrorType<LoggerControllerHealthCheck503>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useLoggerControllerHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof loggerControllerHealthCheck>>>, TError = ErrorType<LoggerControllerHealthCheck503>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getLoggerControllerHealthCheckInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getLoggerControllerHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError = ErrorType<LoggerControllerHealthCheck503>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLoggerControllerHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof loggerControllerHealthCheck>>> = ({ signal }) => loggerControllerHealthCheck(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type LoggerControllerHealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof loggerControllerHealthCheck>>>
export type LoggerControllerHealthCheckQueryError = ErrorType<LoggerControllerHealthCheck503>


export function useLoggerControllerHealthCheck<TData = Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError = ErrorType<LoggerControllerHealthCheck503>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof loggerControllerHealthCheck>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useLoggerControllerHealthCheck<TData = Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError = ErrorType<LoggerControllerHealthCheck503>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof loggerControllerHealthCheck>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useLoggerControllerHealthCheck<TData = Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError = ErrorType<LoggerControllerHealthCheck503>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useLoggerControllerHealthCheck<TData = Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError = ErrorType<LoggerControllerHealthCheck503>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof loggerControllerHealthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getLoggerControllerHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




