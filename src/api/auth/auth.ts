/**
 * Generated by orval v7.3.0 üç∫
 * Do not edit manually.
 * Okami API
 * The Okami rest api
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import type {
  AccessToken,
  CreateAdminHashCodeDto,
  CreateUserDto,
  MakeSessionDto,
  RefreshTokenDto,
  RefreshTokenModel,
  RefreshTokenOnlyModel,
  ResetPasswordDto,
  ResetUserPasswordDto,
  SendResetPasswordEmailDto,
  TokenModel,
  UpdateNotionDatabaseIdDto,
  UpdateUserDto,
  UserHttp,
  ValidateEmailDto,
} from ".././models";
import { customInstance } from "../../lib/axios/index";
import type { ErrorType, BodyType } from "../../lib/axios/index";

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

export const authControllerMakeSession = (
  makeSessionDto: BodyType<MakeSessionDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TokenModel>(
    {
      url: `/auth/login`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: makeSessionDto,
      signal,
    },
    options,
  );
};

export const getAuthControllerMakeSessionMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerMakeSession>>,
    TError,
    { data: BodyType<MakeSessionDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerMakeSession>>,
  TError,
  { data: BodyType<MakeSessionDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerMakeSession>>,
    { data: BodyType<MakeSessionDto> }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerMakeSession(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerMakeSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerMakeSession>>
>;
export type AuthControllerMakeSessionMutationBody = BodyType<MakeSessionDto>;
export type AuthControllerMakeSessionMutationError = ErrorType<unknown>;

export const useAuthControllerMakeSession = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerMakeSession>>,
    TError,
    { data: BodyType<MakeSessionDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authControllerMakeSession>>,
  TError,
  { data: BodyType<MakeSessionDto> },
  TContext
> => {
  const mutationOptions = getAuthControllerMakeSessionMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerLoginV2 = (
  makeSessionDto: BodyType<MakeSessionDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RefreshTokenModel>(
    {
      url: `/auth/v2/login`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: makeSessionDto,
      signal,
    },
    options,
  );
};

export const getAuthControllerLoginV2MutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerLoginV2>>,
    TError,
    { data: BodyType<MakeSessionDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerLoginV2>>,
  TError,
  { data: BodyType<MakeSessionDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerLoginV2>>,
    { data: BodyType<MakeSessionDto> }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerLoginV2(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerLoginV2MutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLoginV2>>>;
export type AuthControllerLoginV2MutationBody = BodyType<MakeSessionDto>;
export type AuthControllerLoginV2MutationError = ErrorType<unknown>;

export const useAuthControllerLoginV2 = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerLoginV2>>,
    TError,
    { data: BodyType<MakeSessionDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authControllerLoginV2>>,
  TError,
  { data: BodyType<MakeSessionDto> },
  TContext
> => {
  const mutationOptions = getAuthControllerLoginV2MutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerRefreshToken = (
  refreshTokenDto: BodyType<RefreshTokenDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RefreshTokenOnlyModel>(
    {
      url: `/auth/v2/refresh-token`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: refreshTokenDto,
      signal,
    },
    options,
  );
};

export const getAuthControllerRefreshTokenMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerRefreshToken>>,
    TError,
    { data: BodyType<RefreshTokenDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerRefreshToken>>,
  TError,
  { data: BodyType<RefreshTokenDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerRefreshToken>>,
    { data: BodyType<RefreshTokenDto> }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerRefreshToken(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerRefreshTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerRefreshToken>>
>;
export type AuthControllerRefreshTokenMutationBody = BodyType<RefreshTokenDto>;
export type AuthControllerRefreshTokenMutationError = ErrorType<unknown>;

export const useAuthControllerRefreshToken = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerRefreshToken>>,
    TError,
    { data: BodyType<RefreshTokenDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authControllerRefreshToken>>,
  TError,
  { data: BodyType<RefreshTokenDto> },
  TContext
> => {
  const mutationOptions = getAuthControllerRefreshTokenMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerUploadAvatarImage = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  formData.append("data");

  return customInstance<void>(
    {
      url: `/auth/user/avatar/upload`,
      method: "POST",
      headers: { "Content-Type": "multipart/form-data" },
      data: formData,
      signal,
    },
    options,
  );
};

export const getAuthControllerUploadAvatarImageMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof authControllerUploadAvatarImage>>, TError, void, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof authControllerUploadAvatarImage>>, TError, void, TContext> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerUploadAvatarImage>>, void> = () => {
    return authControllerUploadAvatarImage(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerUploadAvatarImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerUploadAvatarImage>>
>;

export type AuthControllerUploadAvatarImageMutationError = ErrorType<unknown>;

export const useAuthControllerUploadAvatarImage = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof authControllerUploadAvatarImage>>, TError, void, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<Awaited<ReturnType<typeof authControllerUploadAvatarImage>>, TError, void, TContext> => {
  const mutationOptions = getAuthControllerUploadAvatarImageMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerGetMe = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
  return customInstance<UserHttp>({ url: `/auth/user/me`, method: "GET", signal }, options);
};

export const getAuthControllerGetMeQueryKey = () => {
  return [`/auth/user/me`] as const;
};

export const getAuthControllerGetMeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetMe>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerGetMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetMe>>> = ({ signal }) =>
    authControllerGetMe(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authControllerGetMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AuthControllerGetMeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetMe>>>;
export type AuthControllerGetMeInfiniteQueryError = ErrorType<unknown>;

export function useAuthControllerGetMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetMe>>>,
  TError = ErrorType<unknown>,
>(options: {
  query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>, "initialData">;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerGetMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetMe>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>, "initialData">;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerGetMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetMe>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useAuthControllerGetMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetMe>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAuthControllerGetMeInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthControllerGetMeQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerGetMe>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerGetMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetMe>>> = ({ signal }) =>
    authControllerGetMe(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authControllerGetMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AuthControllerGetMeQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetMe>>>;
export type AuthControllerGetMeQueryError = ErrorType<unknown>;

export function useAuthControllerGetMe<
  TData = Awaited<ReturnType<typeof authControllerGetMe>>,
  TError = ErrorType<unknown>,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>, "initialData">;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerGetMe<
  TData = Awaited<ReturnType<typeof authControllerGetMe>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>, "initialData">;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerGetMe<
  TData = Awaited<ReturnType<typeof authControllerGetMe>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useAuthControllerGetMe<
  TData = Awaited<ReturnType<typeof authControllerGetMe>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetMe>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAuthControllerGetMeQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const authControllerCreateAccessToken = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AccessToken>({ url: `/auth/access-token`, method: "POST", signal }, options);
};

export const getAuthControllerCreateAccessTokenMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof authControllerCreateAccessToken>>, TError, void, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof authControllerCreateAccessToken>>, TError, void, TContext> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerCreateAccessToken>>, void> = () => {
    return authControllerCreateAccessToken(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerCreateAccessTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerCreateAccessToken>>
>;

export type AuthControllerCreateAccessTokenMutationError = ErrorType<unknown>;

export const useAuthControllerCreateAccessToken = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof authControllerCreateAccessToken>>, TError, void, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<Awaited<ReturnType<typeof authControllerCreateAccessToken>>, TError, void, TContext> => {
  const mutationOptions = getAuthControllerCreateAccessTokenMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerRegister = (
  createUserDto: BodyType<CreateUserDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>(
    {
      url: `/auth/register`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createUserDto,
      signal,
    },
    options,
  );
};

export const getAuthControllerRegisterMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerRegister>>,
    TError,
    { data: BodyType<CreateUserDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerRegister>>,
  TError,
  { data: BodyType<CreateUserDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerRegister>>,
    { data: BodyType<CreateUserDto> }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerRegister(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRegister>>>;
export type AuthControllerRegisterMutationBody = BodyType<CreateUserDto>;
export type AuthControllerRegisterMutationError = ErrorType<unknown>;

export const useAuthControllerRegister = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerRegister>>,
    TError,
    { data: BodyType<CreateUserDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authControllerRegister>>,
  TError,
  { data: BodyType<CreateUserDto> },
  TContext
> => {
  const mutationOptions = getAuthControllerRegisterMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerCreateAdminHashCode = (
  createAdminHashCodeDto: BodyType<CreateAdminHashCodeDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>(
    {
      url: `/auth/admin-hash-code`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createAdminHashCodeDto,
      signal,
    },
    options,
  );
};

export const getAuthControllerCreateAdminHashCodeMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerCreateAdminHashCode>>,
    TError,
    { data: BodyType<CreateAdminHashCodeDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerCreateAdminHashCode>>,
  TError,
  { data: BodyType<CreateAdminHashCodeDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerCreateAdminHashCode>>,
    { data: BodyType<CreateAdminHashCodeDto> }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerCreateAdminHashCode(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerCreateAdminHashCodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerCreateAdminHashCode>>
>;
export type AuthControllerCreateAdminHashCodeMutationBody = BodyType<CreateAdminHashCodeDto>;
export type AuthControllerCreateAdminHashCodeMutationError = ErrorType<unknown>;

export const useAuthControllerCreateAdminHashCode = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerCreateAdminHashCode>>,
    TError,
    { data: BodyType<CreateAdminHashCodeDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authControllerCreateAdminHashCode>>,
  TError,
  { data: BodyType<CreateAdminHashCodeDto> },
  TContext
> => {
  const mutationOptions = getAuthControllerCreateAdminHashCodeMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerResetPassword = (
  resetPasswordDto: BodyType<ResetPasswordDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>(
    {
      url: `/auth/reset-password`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: resetPasswordDto,
      signal,
    },
    options,
  );
};

export const getAuthControllerResetPasswordMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerResetPassword>>,
    TError,
    { data: BodyType<ResetPasswordDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerResetPassword>>,
  TError,
  { data: BodyType<ResetPasswordDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerResetPassword>>,
    { data: BodyType<ResetPasswordDto> }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerResetPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerResetPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerResetPassword>>
>;
export type AuthControllerResetPasswordMutationBody = BodyType<ResetPasswordDto>;
export type AuthControllerResetPasswordMutationError = ErrorType<unknown>;

export const useAuthControllerResetPassword = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerResetPassword>>,
    TError,
    { data: BodyType<ResetPasswordDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authControllerResetPassword>>,
  TError,
  { data: BodyType<ResetPasswordDto> },
  TContext
> => {
  const mutationOptions = getAuthControllerResetPasswordMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerLogout = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
  return customInstance<void>({ url: `/auth/logout`, method: "POST", signal }, options);
};

export const getAuthControllerLogoutMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError, void, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError, void, TContext> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogout>>, void> = () => {
    return authControllerLogout(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogout>>>;

export type AuthControllerLogoutMutationError = ErrorType<unknown>;

export const useAuthControllerLogout = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError, void, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<Awaited<ReturnType<typeof authControllerLogout>>, TError, void, TContext> => {
  const mutationOptions = getAuthControllerLogoutMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerCreateMobileSession = (
  makeSessionDto: BodyType<MakeSessionDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>(
    {
      url: `/auth/login-mobile`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: makeSessionDto,
      signal,
    },
    options,
  );
};

export const getAuthControllerCreateMobileSessionMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerCreateMobileSession>>,
    TError,
    { data: BodyType<MakeSessionDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerCreateMobileSession>>,
  TError,
  { data: BodyType<MakeSessionDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerCreateMobileSession>>,
    { data: BodyType<MakeSessionDto> }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerCreateMobileSession(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerCreateMobileSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerCreateMobileSession>>
>;
export type AuthControllerCreateMobileSessionMutationBody = BodyType<MakeSessionDto>;
export type AuthControllerCreateMobileSessionMutationError = ErrorType<unknown>;

export const useAuthControllerCreateMobileSession = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerCreateMobileSession>>,
    TError,
    { data: BodyType<MakeSessionDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authControllerCreateMobileSession>>,
  TError,
  { data: BodyType<MakeSessionDto> },
  TContext
> => {
  const mutationOptions = getAuthControllerCreateMobileSessionMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerUpdateNotionDatabaseId = (
  updateNotionDatabaseIdDto: BodyType<UpdateNotionDatabaseIdDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>(
    {
      url: `/auth/notion/update-database-id`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: updateNotionDatabaseIdDto,
      signal,
    },
    options,
  );
};

export const getAuthControllerUpdateNotionDatabaseIdMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerUpdateNotionDatabaseId>>,
    TError,
    { data: BodyType<UpdateNotionDatabaseIdDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerUpdateNotionDatabaseId>>,
  TError,
  { data: BodyType<UpdateNotionDatabaseIdDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerUpdateNotionDatabaseId>>,
    { data: BodyType<UpdateNotionDatabaseIdDto> }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerUpdateNotionDatabaseId(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerUpdateNotionDatabaseIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerUpdateNotionDatabaseId>>
>;
export type AuthControllerUpdateNotionDatabaseIdMutationBody = BodyType<UpdateNotionDatabaseIdDto>;
export type AuthControllerUpdateNotionDatabaseIdMutationError = ErrorType<unknown>;

export const useAuthControllerUpdateNotionDatabaseId = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerUpdateNotionDatabaseId>>,
    TError,
    { data: BodyType<UpdateNotionDatabaseIdDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authControllerUpdateNotionDatabaseId>>,
  TError,
  { data: BodyType<UpdateNotionDatabaseIdDto> },
  TContext
> => {
  const mutationOptions = getAuthControllerUpdateNotionDatabaseIdMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerFetchUserAnalytics = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>({ url: `/auth/user/analytics`, method: "GET", signal }, options);
};

export const getAuthControllerFetchUserAnalyticsQueryKey = () => {
  return [`/auth/user/analytics`] as const;
};

export const getAuthControllerFetchUserAnalyticsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerFetchUserAnalyticsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>> = ({ signal }) =>
    authControllerFetchUserAnalytics(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AuthControllerFetchUserAnalyticsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>
>;
export type AuthControllerFetchUserAnalyticsInfiniteQueryError = ErrorType<unknown>;

export function useAuthControllerFetchUserAnalyticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>>,
  TError = ErrorType<unknown>,
>(options: {
  query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>> &
    Pick<
      DefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerFetchUserAnalyticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerFetchUserAnalyticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useAuthControllerFetchUserAnalyticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAuthControllerFetchUserAnalyticsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthControllerFetchUserAnalyticsQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerFetchUserAnalyticsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>> = ({ signal }) =>
    authControllerFetchUserAnalytics(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AuthControllerFetchUserAnalyticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>
>;
export type AuthControllerFetchUserAnalyticsQueryError = ErrorType<unknown>;

export function useAuthControllerFetchUserAnalytics<
  TData = Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>,
  TError = ErrorType<unknown>,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>> &
    Pick<
      DefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerFetchUserAnalytics<
  TData = Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>> &
    Pick<
      UndefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerFetchUserAnalytics<
  TData = Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useAuthControllerFetchUserAnalytics<
  TData = Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerFetchUserAnalytics>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAuthControllerFetchUserAnalyticsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const authControllerGetUserTrialQuoteGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>({ url: `/auth/user/trial-quote`, method: "GET", signal }, options);
};

export const getAuthControllerGetUserTrialQuoteGetQueryKey = () => {
  return [`/auth/user/trial-quote`] as const;
};

export const getAuthControllerGetUserTrialQuoteGetInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerGetUserTrialQuoteGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>> = ({ signal }) =>
    authControllerGetUserTrialQuoteGet(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AuthControllerGetUserTrialQuoteGetInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>
>;
export type AuthControllerGetUserTrialQuoteGetInfiniteQueryError = ErrorType<unknown>;

export function useAuthControllerGetUserTrialQuoteGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>>,
  TError = ErrorType<unknown>,
>(options: {
  query: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerGetUserTrialQuoteGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerGetUserTrialQuoteGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useAuthControllerGetUserTrialQuoteGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAuthControllerGetUserTrialQuoteGetInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthControllerGetUserTrialQuoteGetQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerGetUserTrialQuoteGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>> = ({ signal }) =>
    authControllerGetUserTrialQuoteGet(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AuthControllerGetUserTrialQuoteGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>
>;
export type AuthControllerGetUserTrialQuoteGetQueryError = ErrorType<unknown>;

export function useAuthControllerGetUserTrialQuoteGet<
  TData = Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>,
  TError = ErrorType<unknown>,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>> &
    Pick<
      DefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerGetUserTrialQuoteGet<
  TData = Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>> &
    Pick<
      UndefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerGetUserTrialQuoteGet<
  TData = Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useAuthControllerGetUserTrialQuoteGet<
  TData = Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetUserTrialQuoteGet>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAuthControllerGetUserTrialQuoteGetQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const authControllerGetTelegramStatus = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>({ url: `/auth/user/telegram-status`, method: "GET", signal }, options);
};

export const getAuthControllerGetTelegramStatusQueryKey = () => {
  return [`/auth/user/telegram-status`] as const;
};

export const getAuthControllerGetTelegramStatusInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerGetTelegramStatusQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>> = ({ signal }) =>
    authControllerGetTelegramStatus(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authControllerGetTelegramStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AuthControllerGetTelegramStatusInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authControllerGetTelegramStatus>>
>;
export type AuthControllerGetTelegramStatusInfiniteQueryError = ErrorType<unknown>;

export function useAuthControllerGetTelegramStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>>,
  TError = ErrorType<unknown>,
>(options: {
  query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>> &
    Pick<
      DefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerGetTelegramStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>> &
    Pick<
      UndefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerGetTelegramStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useAuthControllerGetTelegramStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAuthControllerGetTelegramStatusInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthControllerGetTelegramStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerGetTelegramStatus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthControllerGetTelegramStatusQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>> = ({ signal }) =>
    authControllerGetTelegramStatus(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authControllerGetTelegramStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AuthControllerGetTelegramStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof authControllerGetTelegramStatus>>
>;
export type AuthControllerGetTelegramStatusQueryError = ErrorType<unknown>;

export function useAuthControllerGetTelegramStatus<
  TData = Awaited<ReturnType<typeof authControllerGetTelegramStatus>>,
  TError = ErrorType<unknown>,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>> &
    Pick<
      DefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerGetTelegramStatus<
  TData = Awaited<ReturnType<typeof authControllerGetTelegramStatus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>> &
    Pick<
      UndefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthControllerGetTelegramStatus<
  TData = Awaited<ReturnType<typeof authControllerGetTelegramStatus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useAuthControllerGetTelegramStatus<
  TData = Awaited<ReturnType<typeof authControllerGetTelegramStatus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTelegramStatus>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAuthControllerGetTelegramStatusQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const authControllerSendResetPasswordEmail = (
  sendResetPasswordEmailDto: BodyType<SendResetPasswordEmailDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>(
    {
      url: `/auth/password/send-reset-email`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: sendResetPasswordEmailDto,
      signal,
    },
    options,
  );
};

export const getAuthControllerSendResetPasswordEmailMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerSendResetPasswordEmail>>,
    TError,
    { data: BodyType<SendResetPasswordEmailDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerSendResetPasswordEmail>>,
  TError,
  { data: BodyType<SendResetPasswordEmailDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerSendResetPasswordEmail>>,
    { data: BodyType<SendResetPasswordEmailDto> }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerSendResetPasswordEmail(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerSendResetPasswordEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerSendResetPasswordEmail>>
>;
export type AuthControllerSendResetPasswordEmailMutationBody = BodyType<SendResetPasswordEmailDto>;
export type AuthControllerSendResetPasswordEmailMutationError = ErrorType<unknown>;

export const useAuthControllerSendResetPasswordEmail = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerSendResetPasswordEmail>>,
    TError,
    { data: BodyType<SendResetPasswordEmailDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authControllerSendResetPasswordEmail>>,
  TError,
  { data: BodyType<SendResetPasswordEmailDto> },
  TContext
> => {
  const mutationOptions = getAuthControllerSendResetPasswordEmailMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerResetUserPassword = (
  resetUserPasswordDto: BodyType<ResetUserPasswordDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>(
    {
      url: `/auth/password/reset`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: resetUserPasswordDto,
      signal,
    },
    options,
  );
};

export const getAuthControllerResetUserPasswordMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerResetUserPassword>>,
    TError,
    { data: BodyType<ResetUserPasswordDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerResetUserPassword>>,
  TError,
  { data: BodyType<ResetUserPasswordDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerResetUserPassword>>,
    { data: BodyType<ResetUserPasswordDto> }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerResetUserPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerResetUserPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerResetUserPassword>>
>;
export type AuthControllerResetUserPasswordMutationBody = BodyType<ResetUserPasswordDto>;
export type AuthControllerResetUserPasswordMutationError = ErrorType<unknown>;

export const useAuthControllerResetUserPassword = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerResetUserPassword>>,
    TError,
    { data: BodyType<ResetUserPasswordDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authControllerResetUserPassword>>,
  TError,
  { data: BodyType<ResetUserPasswordDto> },
  TContext
> => {
  const mutationOptions = getAuthControllerResetUserPasswordMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerUpdateUser = (
  updateUserDto: BodyType<UpdateUserDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<void>(
    { url: `/auth/user`, method: "PUT", headers: { "Content-Type": "application/json" }, data: updateUserDto },
    options,
  );
};

export const getAuthControllerUpdateUserMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerUpdateUser>>,
    TError,
    { data: BodyType<UpdateUserDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerUpdateUser>>,
  TError,
  { data: BodyType<UpdateUserDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerUpdateUser>>,
    { data: BodyType<UpdateUserDto> }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerUpdateUser(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerUpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerUpdateUser>>>;
export type AuthControllerUpdateUserMutationBody = BodyType<UpdateUserDto>;
export type AuthControllerUpdateUserMutationError = ErrorType<unknown>;

export const useAuthControllerUpdateUser = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerUpdateUser>>,
    TError,
    { data: BodyType<UpdateUserDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authControllerUpdateUser>>,
  TError,
  { data: BodyType<UpdateUserDto> },
  TContext
> => {
  const mutationOptions = getAuthControllerUpdateUserMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerSendConfirmEmail = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>({ url: `/auth/user/send-confirm-email`, method: "POST", signal }, options);
};

export const getAuthControllerSendConfirmEmailMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof authControllerSendConfirmEmail>>, TError, void, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof authControllerSendConfirmEmail>>, TError, void, TContext> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerSendConfirmEmail>>, void> = () => {
    return authControllerSendConfirmEmail(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerSendConfirmEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerSendConfirmEmail>>
>;

export type AuthControllerSendConfirmEmailMutationError = ErrorType<unknown>;

export const useAuthControllerSendConfirmEmail = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof authControllerSendConfirmEmail>>, TError, void, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<Awaited<ReturnType<typeof authControllerSendConfirmEmail>>, TError, void, TContext> => {
  const mutationOptions = getAuthControllerSendConfirmEmailMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authControllerValidateEmailCode = (
  validateEmailDto: BodyType<ValidateEmailDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>(
    {
      url: `/auth/user/validate-email`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: validateEmailDto,
      signal,
    },
    options,
  );
};

export const getAuthControllerValidateEmailCodeMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerValidateEmailCode>>,
    TError,
    { data: BodyType<ValidateEmailDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerValidateEmailCode>>,
  TError,
  { data: BodyType<ValidateEmailDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerValidateEmailCode>>,
    { data: BodyType<ValidateEmailDto> }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerValidateEmailCode(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerValidateEmailCodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerValidateEmailCode>>
>;
export type AuthControllerValidateEmailCodeMutationBody = BodyType<ValidateEmailDto>;
export type AuthControllerValidateEmailCodeMutationError = ErrorType<unknown>;

export const useAuthControllerValidateEmailCode = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerValidateEmailCode>>,
    TError,
    { data: BodyType<ValidateEmailDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authControllerValidateEmailCode>>,
  TError,
  { data: BodyType<ValidateEmailDto> },
  TContext
> => {
  const mutationOptions = getAuthControllerValidateEmailCodeMutationOptions(options);

  return useMutation(mutationOptions);
};
